<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计LRU缓存结构</title>
    <link href="/2021/10/24/algorithm-test-1024/"/>
    <url>/2021/10/24/algorithm-test-1024/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计LRU(最近最少使用)缓存结构，该结构在构造时确定大小，假设大小为 k ，并有如下两个功能</p><ol><li>set(key, value)：将记录(key, value)插入该结构</li><li>get(key)：返回key对应的value值</li></ol><p>提示:<br>1.某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的，然后都会刷新缓存。<br>2.当缓存的大小超过k时，移除最不经常使用的记录。<br>3.输入一个二维数组与k，二维数组每一维有2个或者3个数字，第1个数字为opt，第2，3个数字为key，value<br>若opt=1，接下来两个整数key, value，表示set(key, value)<br>若opt=2，接下来一个整数key，表示get(key)，若key未出现过或已被移除，则返回-1<br>对于每个opt=2，输出一个答案<br>4.为了方便区分缓存里key与value，下面说明的缓存里key用””号包裹</p><p>要求：set和get操作复杂度均为 O(1)O(1)</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]],<span class="hljs-number">3</span><br>复制<br>返回值：<br>[<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>]<br>复制<br>说明：<br>[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]，第一个<span class="hljs-number">1</span>表示opt=<span class="hljs-number">1</span>，要set(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)，即将(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)插入缓存，缓存是&#123;<span class="hljs-string">&quot;1&quot;</span>=<span class="hljs-number">1</span>&#125;<br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]，第一个<span class="hljs-number">1</span>表示opt=<span class="hljs-number">1</span>，要set(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)，即将(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)插入缓存，缓存是&#123;<span class="hljs-string">&quot;1&quot;</span>=<span class="hljs-number">1</span>,<span class="hljs-string">&quot;2&quot;</span>=<span class="hljs-number">2</span>&#125;<br>[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]，第一个<span class="hljs-number">1</span>表示opt=<span class="hljs-number">1</span>，要set(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)，即将(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)插入缓存，缓存是&#123;<span class="hljs-string">&quot;1&quot;</span>=<span class="hljs-number">1</span>,<span class="hljs-string">&quot;2&quot;</span>=<span class="hljs-number">2</span>,<span class="hljs-string">&quot;3&quot;</span>=<span class="hljs-number">2</span>&#125;<br>[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]，第一个<span class="hljs-number">2</span>表示opt=<span class="hljs-number">2</span>，要get(<span class="hljs-number">1</span>)，返回是[<span class="hljs-number">1</span>]，因为get(<span class="hljs-number">1</span>)操作，缓存更新，缓存是&#123;<span class="hljs-string">&quot;2&quot;</span>=<span class="hljs-number">2</span>,<span class="hljs-string">&quot;3&quot;</span>=<span class="hljs-number">2</span>,<span class="hljs-string">&quot;1&quot;</span>=<span class="hljs-number">1</span>&#125;<br>[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]，第一个<span class="hljs-number">1</span>表示opt=<span class="hljs-number">1</span>，要set(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)，即将(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)插入缓存，但是缓存已经达到最大容量<span class="hljs-number">3</span>，移除最不经常使用的&#123;<span class="hljs-string">&quot;2&quot;</span>=<span class="hljs-number">2</span>&#125;，插入&#123;<span class="hljs-string">&quot;4&quot;</span>=<span class="hljs-number">4</span>&#125;，缓存是&#123;<span class="hljs-string">&quot;3&quot;</span>=<span class="hljs-number">2</span>,<span class="hljs-string">&quot;1&quot;</span>=<span class="hljs-number">1</span>,<span class="hljs-string">&quot;4&quot;</span>=<span class="hljs-number">4</span>&#125;<br>[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]，第一个<span class="hljs-number">2</span>表示opt=<span class="hljs-number">2</span>，要get(<span class="hljs-number">2</span>)，查找不到，返回是[<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>]     <br></code></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,1]</span>,<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[2,1]</span>,<span class="hljs-comment">[1,3,3]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[1,4,4]</span>,<span class="hljs-comment">[2,1]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[2,4]</span>]</span>,2<br>复制<br>返回值：<br><span class="hljs-comment">[1,-1,-1,3,4]</span><br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>用一个 map 来存储 cache 值，result 存储返回值</li><li>遍历所有的 operators，分 set 和 get 操作</li><li>set: 当 cache 的 size 小于 k 时，如果 cache 中有这个值，则删除这个值，并重新添加到 map 的末尾<br>当 cache 的 size 大于等于 k 时，如果 cache 中有这个值，则删除这个值，并重新添加到 map 的末尾；当不存在<br>这个值时，需要删除 map 中第一个元素，然后再添加到 map 的末尾。</li><li>get: 当 cache 中有这个值时，添加到 result 数组中，并把 cache 中这个 key 的值删除，重新添加到末尾（已被使用）。</li></ol><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * lru design</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>operators int整型二维数组 the ops</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>k int整型 the k</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return </span>int整型一维数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LRU</span>(<span class="hljs-params">operators, k</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>    <span class="hljs-keyword">const</span> result = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, n = operators.length; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">const</span> item = operators[i]<br>        <span class="hljs-comment">// set</span><br>        <span class="hljs-keyword">if</span> (item[<span class="hljs-number">0</span>] === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cache.size &lt; k) &#123;<br>                <span class="hljs-comment">// map 结构里有这个值,删除，添加新值到最后</span><br>                <span class="hljs-keyword">if</span> (cache.has(item[<span class="hljs-number">1</span>])) &#123;<br>                    cache.delete(item[<span class="hljs-number">1</span>])<br>                    cache.set(item[<span class="hljs-number">1</span>], item[<span class="hljs-number">2</span>])<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    cache.set(item[<span class="hljs-number">1</span>], item[<span class="hljs-number">2</span>])<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (cache.has(item[<span class="hljs-number">1</span>])) &#123;<br>                    cache.delete(item[<span class="hljs-number">1</span>])<br>                    cache.set(item[<span class="hljs-number">1</span>], item[<span class="hljs-number">2</span>])<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 删除第一个数，然后添加到末尾</span><br>                    <span class="hljs-keyword">const</span> firstKey = cache.entries().next().value[<span class="hljs-number">0</span>]<br>                    cache.delete(firstKey)<br>                    cache.set(item[<span class="hljs-number">1</span>], item[<span class="hljs-number">2</span>])<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item[<span class="hljs-number">0</span>] === <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cache.has(item[<span class="hljs-number">1</span>])) &#123;<br>                <span class="hljs-keyword">const</span> value = cache.get(item[<span class="hljs-number">1</span>])<br>                result.push(value)<br>                <span class="hljs-comment">// 把值放到最后</span><br>                cache.delete(item[<span class="hljs-number">1</span>])<br>                cache.set(item[<span class="hljs-number">1</span>], value)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.push(-<span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">LRU</span>: LRU<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何用 vue3 开发 IDE 插件</title>
    <link href="/2021/07/25/vue3-extension-template/"/>
    <url>/2021/07/25/vue3-extension-template/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当你想写 IDE 插件的时候，是否觉得原生的写法太过麻烦，为什么不能用框架来写？当 webview 里的页面有十分复杂的交互的时候，写插件里的页面就变成了一件十分头疼的事，任凭外面的框架如何花里胡哨，你也只能使用原生的写法来实现，本文将介绍如何把 Vue3 运用到插件里来开发。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="创建插件"><a href="#创建插件" class="headerlink" title="创建插件"></a>创建插件</h2><p>全局安装 yo 和 generator-code:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g yo generator-code<br></code></pre></td></tr></table></figure><p>按照步骤，新建插件，选择 Typescript 来开发插件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">yo code<br><br> _-----_     ╭──────────────────────────╮<br>|       |    │   Welcome to the Visual  │<br>|--(o)--|    │   Studio Code Extension  │<br>`---------´   │        generator!        │<br>( _´U`_ )    ╰──────────────────────────╯<br>/___A___\   /<br> |  ~  |<br>__&#x27;.___.&#x27;__<br>´   `  |° ´ Y `<br><br> ? What type of extension do you want to create? New Extension (TypeScript)<br> ? What&#x27;s the name of your extension? helloWorld<br> ? What&#x27;s the identifier of your extension? helloworld<br> ? What&#x27;s the description of your extension?<br> ? Initialize a git repository? No<br> ? Bundle the source code with webpack? Yes<br> ? Which package manager to use?<br> npm<br> ❯ yarn<br></code></pre></td></tr></table></figure><h2 id="新建-vue-项目"><a href="#新建-vue-项目" class="headerlink" title="新建 vue 项目"></a>新建 vue 项目</h2><p>进入插件目录，新建一个名为 frontend 的 vue 项目，需要先安装 vue cli。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vue create frontend<br></code></pre></td></tr></table></figure><p>此时，你会发现，这里的 vue 项目还是 js 的，我们把它换成 ts 的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vue add typescript<br></code></pre></td></tr></table></figure><p>注意： 其中的 Convert all .js files to .ts 选项选 Y。</p><h1 id="新建插件要打开的-panel"><a href="#新建插件要打开的-panel" class="headerlink" title="新建插件要打开的 panel"></a>新建插件要打开的 panel</h1><p>新建 TemplatePanel 类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// TemplatePanel.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplatePanel</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> currentPanel: TemplatePanel | <span class="hljs-literal">undefined</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> _panel: vscode.WebviewPanel;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> _context: vscode.ExtensionContext;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> _extensionPath: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-keyword">private</span> _disposables: vscode.Disposable[] = [];<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    panel: vscode.WebviewPanel,</span></span><br><span class="hljs-params"><span class="hljs-function">    context: vscode.ExtensionContext</span></span><br><span class="hljs-params"><span class="hljs-function">  </span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._panel = panel;<br>    <span class="hljs-built_in">this</span>._context = context;<br>    <span class="hljs-built_in">this</span>._extensionPath = context.extensionPath;<br>    <span class="hljs-built_in">this</span>.initialize();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">initialize</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._panel.onDidDispose(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.dispose(), <span class="hljs-literal">null</span>, <span class="hljs-built_in">this</span>._disposables);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params">context: vscode.ExtensionContext</span>)</span> &#123;<br>    <span class="hljs-comment">// 如果打开了页面，不重复打开</span><br>    <span class="hljs-keyword">if</span> (TemplatePanel.currentPanel) &#123;<br>      <span class="hljs-keyword">const</span> column = vscode.window.activeTextEditor<br>        ? vscode.window.activeTextEditor.viewColumn<br>        : <span class="hljs-literal">undefined</span>;<br>      TemplatePanel.currentPanel._panel.reveal(column);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> panel = vscode.window.createWebviewPanel(<br>      <span class="hljs-string">&quot;Template&quot;</span>,<br>      localize(<span class="hljs-string">&quot;template&quot;</span>),<br>      vscode.ViewColumn.Active,<br>      &#123;<br>        <span class="hljs-attr">enableScripts</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">retainContextWhenHidden</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// 用于 IDE 自带的文件协议的可读路径</span><br>        <span class="hljs-attr">localResourceRoots</span>: [<br>          vscode.Uri.file(path.join(context.extensionPath, <span class="hljs-string">&quot;media&quot;</span>)),<br>          vscode.Uri.file(path.join(context.extensionPath, <span class="hljs-string">&quot;frontend&quot;</span>, <span class="hljs-string">&quot;dist&quot;</span>)),<br>        ],<br>      &#125;<br>    );<br><br>    TemplatePanel.currentPanel = <span class="hljs-keyword">new</span> TemplatePanel(panel, context);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">dispose</span>(<span class="hljs-params"></span>)</span> &#123;<br>    TemplatePanel.currentPanel = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-built_in">this</span>._panel.dispose();<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>._disposables.length) &#123;<br>      <span class="hljs-keyword">const</span> x = <span class="hljs-built_in">this</span>._disposables.pop();<br>      <span class="hljs-keyword">if</span> (x) &#123;<br>        x.dispose();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何获取-vue-的前端页面"><a href="#如何获取-vue-的前端页面" class="headerlink" title="如何获取 vue 的前端页面"></a>如何获取 vue 的前端页面</h2><p>读取 vue 项目打包后的文件，并把引用的文件路径替换成 IDE 能够识别的文件协议格式。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWebviewContent</span>(<span class="hljs-params">extensionPath: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> distPath = vscode.Uri.file(<br>    path.join(extensionPath, <span class="hljs-string">&quot;frontend&quot;</span>, <span class="hljs-string">&quot;dist&quot;</span>)<br>  ).with(&#123; <span class="hljs-attr">scheme</span>: <span class="hljs-string">&quot;vscode-resource&quot;</span> &#125;);<br>  <span class="hljs-comment">// 读取 dits 下的 index.html</span><br>  <span class="hljs-keyword">let</span> html = <span class="hljs-keyword">await</span> fse.readFile(<br>    path.join(__dirname, <span class="hljs-string">&quot;../frontend/dist/index.html&quot;</span>)<br>  );<br>  <span class="hljs-keyword">const</span> hrefReg = <span class="hljs-regexp">/href=([&quot;&#x27;]&#123;1&#125;)\/&#123;1&#125;([^\/])/gi</span>;<br>  <span class="hljs-keyword">const</span> srcReg = <span class="hljs-regexp">/src=([&quot;&#x27;]&#123;1&#125;)\/&#123;1&#125;([^\/])/gi</span>;<br>  <span class="hljs-comment">// 把文件路径替换成 IDE 能够识别的文件协议格式</span><br>  <span class="hljs-keyword">let</span> str = html<br>    .toString()<br>    .replace(hrefReg, <span class="hljs-string">`href=$1<span class="hljs-subst">$&#123;distPath&#125;</span>/$2`</span>)<br>    .replace(srcReg, <span class="hljs-string">`src=$1<span class="hljs-subst">$&#123;distPath&#125;</span>/$2`</span>);<br>  <span class="hljs-keyword">return</span> str;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 initialize 方法中赋值 webview 的 html：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// TemplatePanel.ts 中的 initialize 方法</span><br><span class="hljs-built_in">this</span>._panel.webview.html = <span class="hljs-keyword">await</span> getWebviewContent(<span class="hljs-built_in">this</span>._extensionPath);<br></code></pre></td></tr></table></figure><h2 id="建立插件端和前端页面（Vue）的通信"><a href="#建立插件端和前端页面（Vue）的通信" class="headerlink" title="建立插件端和前端页面（Vue）的通信"></a>建立插件端和前端页面（Vue）的通信</h2><p>vue 编写的页面相当于是前端（浏览器端），而插件端的逻辑相当于是后端（服务器端），两者需要通信，那怎么才能在不启动服务的情况下进行通信呢，这就要用到 postMessage 了。</p><p>在前端页面中，增加 message 的监听：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> message = event.data;<br>  <span class="hljs-keyword">switch</span> (message.command) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;setMessage&quot;</span>: &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在插件端，也要增加 message 的监听，我们写在 initialize 方法里：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">this</span>._panel.webview.onDidReceiveMessage(<br>  <span class="hljs-keyword">async</span> (message) =&gt; &#123;<br>    <span class="hljs-keyword">switch</span> (message.command) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;getMessage&quot;</span>:<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-literal">null</span>,<br>  <span class="hljs-built_in">this</span>._disposables<br>);<br></code></pre></td></tr></table></figure><p>前端向后端发送消息：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-comment">// 引入 acquireVsCodeApi 的方法</span><br><span class="hljs-keyword">const</span> ide = acquireVsCodeApi();<br><span class="hljs-comment">// 发送消息</span><br>ide.postMessage(&#123;<br>  <span class="hljs-attr">command</span>: <span class="hljs-string">&quot;getMessage&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>后端向前端发送消息：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// templatePanel.ts</span><br><span class="hljs-built_in">this</span>._panel.webview.postMessage(&#123;<br>  <span class="hljs-attr">command</span>: <span class="hljs-string">&quot;setMessage&quot;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello&quot;</span>,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="新增-Vuex"><a href="#新增-Vuex" class="headerlink" title="新增 Vuex"></a>新增 Vuex</h1><p>安装 vuex，由于我们用的是 vue3，所以要安装 vuex@next</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yarn add vuex@next --save<br></code></pre></td></tr></table></figure><p>在 store.ts 中初始化 vuex</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// store.ts</span><br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> store = createStore(&#123;<br>  <span class="hljs-attr">state</span>: &#123;&#125;,<br>  <span class="hljs-attr">modules</span>: &#123;&#125;,<br>&#125;);<br>在 mian.ts 中引入 vuex<br><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">import</span> &#123; store &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store&quot;</span>;<br><span class="hljs-keyword">const</span> app = createApp(App);<br>app.use(store);<br>app.mount(<span class="hljs-string">&quot;#app&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="新增多语言（vue-i18n）"><a href="#新增多语言（vue-i18n）" class="headerlink" title="新增多语言（vue-i18n）"></a>新增多语言（vue-i18n）</h1><p>安装 vue-i18n，由于我们用的是 vue3，所以要安装 vue-i18n@next</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yarn add vue-i18n@next --save<br></code></pre></td></tr></table></figure><p>在 i18n.ts 中初始化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// i18n.ts</span><br><span class="hljs-keyword">import</span> &#123; createI18n &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-i18n&quot;</span>;<br><br><span class="hljs-keyword">const</span> en = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./locale/en.json&quot;</span>);<br><span class="hljs-keyword">const</span> zhCN = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./locale/zh-CN.json&quot;</span>);<br><br><span class="hljs-comment">// 语言包根据语言环境分类</span><br><span class="hljs-keyword">const</span> messages = &#123;<br>  en,<br>  <span class="hljs-string">&quot;zh-CN&quot;</span>: zhCN,<br>&#125;;<br><br><span class="hljs-keyword">const</span> i18n = createI18n(&#123;<br>  <span class="hljs-attr">locale</span>: <span class="hljs-string">&quot;zh-CN&quot;</span>, <span class="hljs-comment">// 设置当前语言环境，默认中文简体</span><br>  messages, <span class="hljs-comment">// 设置语言环境对应信息</span><br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> i18n;<br></code></pre></td></tr></table></figure><p>在 mian.ts 中引入 vue-i18n</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// main.ts</span><br><span class="hljs-keyword">import</span> i18n <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./i18n/index&quot;</span>;<br><span class="hljs-keyword">const</span> app = createApp(App);<br>app.use(i18n);<br>app.mount(<span class="hljs-string">&quot;#app&quot;</span>);<br>可以在代码中切换语言：<br><span class="hljs-built_in">this</span>.$i18n.locale = <span class="hljs-built_in">this</span>.language;<br></code></pre></td></tr></table></figure><h1 id="如何在-vue-项目中使用静态文件"><a href="#如何在-vue-项目中使用静态文件" class="headerlink" title="如何在 vue 项目中使用静态文件"></a>如何在 vue 项目中使用静态文件</h1><p>由于在 IDE 的 webview 中，使用的是 IDE 的文件协议，而不是正常的 file:// 协议。当你直接使用相对路径或者绝对路径时，是找不到静态资源的，那么，要如何才能在 vue 里用上静态资源呢，方法也很简单，只需要在 vue 项目用上 IDE 的文件协议头即可，我们这里把静态资源放在 media 目录下。</p><p>获取文件协议的 uri</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 获取文件协议的 uri</span><br><span class="hljs-built_in">this</span>._panel.webview.asWebviewUri(<br>                  vscode.Uri.file(path.join(<span class="hljs-built_in">this</span>._extensionPath, <span class="hljs-string">&quot;media&quot;</span>))<br>通过之前的通信方式，把 uri 传到前端页面。<br><span class="hljs-built_in">this</span>._panel.webview.postMessage(&#123;<br>              <span class="hljs-attr">command</span>: <span class="hljs-string">&quot;setSetting&quot;</span>,<br>              <span class="hljs-attr">data</span>: &#123;<br>                <span class="hljs-attr">resource</span>: <span class="hljs-built_in">this</span>._panel.webview.asWebviewUri(<br>                  vscode.Uri.file(path.join(<span class="hljs-built_in">this</span>._extensionPath, <span class="hljs-string">&quot;media&quot;</span>))<br>                ),<br>              &#125;,<br></code></pre></td></tr></table></figure><p>前端接收之后把 uri 拼接成文件协议头：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> resource =<br>  message.data.resource.scheme +<br>  <span class="hljs-string">&quot;://&quot;</span> +<br>  message.data.resource.authority +<br>  message.data.resource.path;<br></code></pre></td></tr></table></figure><p>在页面中使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;`$&#123;resource&#125;/images/logo.png`&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>这样就可以在前端页面中使用静态资源了。</p><h1 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h1><p>watch vue 项目内容<br>在 frontend 目录下的 package.json 中配置命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;watch&quot;</span>: <span class="hljs-string">&quot;vue-cli-service build --watch&quot;</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>配置完成之后，运行 yarn watch，即可实时监听代码变化，无需重新 build。</p><h2 id="watch-插件中内容"><a href="#watch-插件中内容" class="headerlink" title="watch 插件中内容"></a>watch 插件中内容</h2><p>由于在创建插件模板的时候，已经自行创建了 watch 命令，所以只需要在项目的根目录运行 yarn watch 即可。</p><h2 id="运用-vscode-调试"><a href="#运用-vscode-调试" class="headerlink" title="运用 vscode 调试"></a>运用 vscode 调试</h2><p>点击侧边栏的「运行和调试」，运行 Run Extension 任务。</p><p>运行之后，会打开一个新的窗口，使用快捷键 mac：cmd + shift + p win：ctrl + shift + p，输入 show panel，即可打开之前写的页面。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了如何用 vue3 来开发 IDE 插件，融合了 vuex、typescript、vue-i18n 等，能够满足日常的开发，如需查看更多的插件开发内容，可查看 文档，有丰富的 api 能够使用。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>项目地址: <a href="">https://github.com/Jerome77777/vue3-ide-extension-template</a></p>]]></content>
    
    
    <categories>
      
      <category>vscode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>koa-middleware</title>
    <link href="/2021/07/18/koa-middleware/"/>
    <url>/2021/07/18/koa-middleware/</url>
    
    <content type="html"><![CDATA[<h1 id="Koa-的核心扩展机制：中间件"><a href="#Koa-的核心扩展机制：中间件" class="headerlink" title="Koa 的核心扩展机制：中间件"></a>Koa 的核心扩展机制：中间件</h1><h2 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h2><p>中间件是框架的扩展机制，主要用于抽象 HTTP 请求过程。在单一请求响应过程中加入中间件，可以更好地应对复杂的业务逻辑。</p><p>如果把 HTTTP 处理过程比作污水处理，那么中间件就像一层层的过滤网。每个中间件在 HTTP 处理过程中通过改写请求和响应数据、状态，实现特定功能。大家都知道 HTTP 是无状态协议，所以 HTTP 请求的过程可以这样理解：请求被发送过来，经过无数中间件拦截直至被响应为止。</p><p><a href="https://imgtu.com/i/W8n5Y8"><img src="https://z3.ax1x.com/2021/07/18/W8n5Y8.jpg" alt="W8n5Y8.jpg"></a></p><p>请求到达服务器后，依次经过各个中间件，直至被响应，所以整个流程会流经 log 中间件，由请求响应（业务逻辑）中间件给与响应，具体描述如下：</p><ul><li>请求到达 log 中间件，记录此时的时间。</li><li>放过，执行 next，此时会执行下一个中间件。</li><li>执行到请求响应中间件，通过 ctx.body 向浏览器输出响应结果。</li><li>当响应回到 log 中间件时，根据当前时间减去请求到达时间，打印请求耗时。</li><li>最后把响应写到浏览器里。</li></ul><h2 id="Koa-v2"><a href="#Koa-v2" class="headerlink" title="Koa v2"></a>Koa v2</h2><p>在简单了解了中间件之后，本文主要介绍 Koa v2 的内容。Koa v2 是一个成熟的 Web 框架，是由 Koa v1 演进而成的。Koa v2 最重要的特性是支持 async 函数，并且同时支持如下 3 种不同类型函数的中间件。</p>]]></content>
    
    
    <categories>
      
      <category>Node</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vscode 依赖注入</title>
    <link href="/2021/07/11/vscode-ioc/"/>
    <url>/2021/07/11/vscode-ioc/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 vscode 的源码中，有许多服务（Service），这些服务提供不同模块的 API 给其他模块使用，在需要依赖该服务的类构造器中用装饰器的形式声明参数，开发者不需要再显式地 new 这个服务对象，在调用者被创建时，这些依赖的服务会被自动创建并传递给调用者，服务之间还能够相互依赖，这样做大幅度地降低了程序的耦合性。本文将带你简单了解 vscode 的依赖注入。</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="Typescript-装饰器"><a href="#Typescript-装饰器" class="headerlink" title="Typescript 装饰器"></a>Typescript 装饰器</h2><p>如果您不太了解 typescript 装饰器，请先阅读我之前的文章<a href="https://chenjiangfeng.xyz/2021/07/03/decorators/">《TypeScript 装饰器》</a></p><h1 id="依赖注入详解"><a href="#依赖注入详解" class="headerlink" title="依赖注入详解"></a>依赖注入详解</h1><h2 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h2><p>定义一个类并在其构造函数中声明依赖的服务</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-meta">@IMyService</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> myService: IMyService</span></span><br><span class="hljs-params"><span class="hljs-function"></span>)</span> &#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在类中使用了一个装饰器 @IMyService，相信你看了预备知识之后，能够清楚地知道这是一个参数装饰器，该装饰器会在运行时被调用，并传入三个参数：</p><ul><li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li><li>成员的名字</li><li>参数在函数参数列表中的索引<br>那么，这个 IMyService 装饰器是如何定义的呢，让我们接下来看：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> IMyService = createDecorator&lt;IMyService&gt;(<span class="hljs-string">&#x27;myService&#x27;</span>);<br><span class="hljs-keyword">interface</span> IMyService &#123;<br><span class="hljs-attr">_serviceBrand</span>: <span class="hljs-literal">undefined</span>;<br>myMethod(): <span class="hljs-built_in">any</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这个服务接口需要具体的实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> <span class="hljs-title">implements</span> <span class="hljs-title">IMyService</span> </span>&#123;<br><span class="hljs-attr">_serviceBrand</span>: <span class="hljs-literal">undefined</span>;<br><span class="hljs-function"><span class="hljs-title">myMethod</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，在声明这个接口之前，有个 createDecorator 函数定义了一个服务的装饰器，用于在构造函数中声明依赖关系以方便注入依赖。createDecorator 的主要作用是返回一个装饰器，让我们来看看是怎么实现的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createDecorator</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">serviceId: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">ServiceIdentifier</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-comment">// 已经保存过的服务直接返回其装饰器</span><br><span class="hljs-keyword">if</span> (_util.serviceIds.has(serviceId)) &#123;<br><span class="hljs-keyword">return</span> _util.serviceIds.get(serviceId)!;<br>&#125;<br><br><span class="hljs-comment">// 声明装饰器，只能被用于参数装饰器</span><br><span class="hljs-keyword">const</span> id = &lt;<span class="hljs-built_in">any</span>&gt;<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target: <span class="hljs-built_in">Function</span>, key: <span class="hljs-built_in">string</span>, index: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">any</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length !== <span class="hljs-number">3</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;@IServiceName-decorator can only be used to decorate a parameter&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 将服务作为依赖保存在目标类的属性中</span><br>storeServiceDependency(id, target, index, <span class="hljs-literal">false</span>);<br>&#125;;<br><br>id.toString = <span class="hljs-function">() =&gt;</span> serviceId;<br><br><span class="hljs-comment">// 在 serviceIds 保存依赖</span><br>_util.serviceIds.set(serviceId, id);<br><span class="hljs-keyword">return</span> id;<br>&#125;<br>storeServiceDependency 函数：<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">storeServiceDependency</span>(<span class="hljs-params">id: <span class="hljs-built_in">Function</span>, target: <span class="hljs-built_in">Function</span>, index: <span class="hljs-built_in">number</span>, optional: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">void</span> </span>&#123;<br><span class="hljs-keyword">if</span> ((target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[_util.DI_TARGET] === target) &#123;<br>(target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[_util.DI_DEPENDENCIES].push(&#123; id, index, optional &#125;);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>(target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[_util.DI_DEPENDENCIES] = [&#123; id, index, optional &#125;];<br>(target <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[_util.DI_TARGET] = target;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>storeServiceDependency 函数将传入的服务 ID (唯一的字符串 myService )及索引保存在所装饰类的一个成员 $di$dependencies 数组中， 对于例子中的 MyClass，其构造函数中的一个参数装饰器会在编译的时候被执行，把依赖记入到 $di$dependencies 数组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts">MyClass[<span class="hljs-string">&#x27;$di$dependencies&#x27;</span>] = [<br>&#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;myService&#x27;</span>, <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">optional</span>: <span class="hljs-literal">false</span> &#125;<br>];<br></code></pre></td></tr></table></figure><h2 id="服务集容器"><a href="#服务集容器" class="headerlink" title="服务集容器"></a>服务集容器</h2><p>上节讲到创建了一个服务，那么有多个服务时，就需要一个服务集，用于保存一组服务。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceCollection</span> </span>&#123;<br><span class="hljs-comment">// 服务集的 map</span><br><span class="hljs-keyword">private</span> _entries = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;ServiceIdentifier&lt;<span class="hljs-built_in">any</span>&gt;, <span class="hljs-built_in">any</span>&gt;();<br><br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">...entries: [ServiceIdentifier&lt;<span class="hljs-built_in">any</span>&gt;, <span class="hljs-built_in">any</span>][]</span>)</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [id, service] <span class="hljs-keyword">of</span> entries) &#123;<br><span class="hljs-built_in">this</span>.set(id, service);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 添加服务</span><br>set&lt;T&gt;(id: ServiceIdentifier&lt;T&gt;, instanceOrDescriptor: T | SyncDescriptor&lt;T&gt;): T | SyncDescriptor&lt;T&gt; &#123;<br><span class="hljs-keyword">const</span> result = <span class="hljs-built_in">this</span>._entries.get(id);<br><span class="hljs-built_in">this</span>._entries.set(id, instanceOrDescriptor);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 是否含有该服务</span><br>has(id: ServiceIdentifier&lt;<span class="hljs-built_in">any</span>&gt;): <span class="hljs-built_in">boolean</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._entries.has(id);<br>&#125;<br><br><span class="hljs-comment">// 获取服务</span><br>get&lt;T&gt;(id: ServiceIdentifier&lt;T&gt;): T | SyncDescriptor&lt;T&gt; &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._entries.get(id);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个服务集容器：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> services = <span class="hljs-keyword">new</span> ServiceCollection();<br><span class="hljs-comment">// 第一个参数为服务的构造器，即 id，如使用装饰器中说到的 myService</span><br><span class="hljs-comment">// 第二个参数为服务的实例对象</span><br>services.set(ILoggerService, <span class="hljs-keyword">new</span> LoggerService(logService, fileService));<br>services.set(ILifecycleMainService, <span class="hljs-keyword">new</span> SyncDescriptor(LifecycleMainService));<br></code></pre></td></tr></table></figure><p>在 vscode 中，有些服务是不依赖其他服务，仅被其他服务所依赖，如日志服务（ILoggerService），此类服务创建的时候可直接 new 服务的对象。有些服务还会依赖别的服务，需要 SyncDescriptor 封装之后保存在服务集中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncDescriptor</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br><span class="hljs-keyword">readonly</span> ctor: <span class="hljs-built_in">any</span>;<br><span class="hljs-keyword">readonly</span> staticArguments: <span class="hljs-built_in">any</span>[];<br><span class="hljs-keyword">readonly</span> supportsDelayedInstantiation: <span class="hljs-built_in">boolean</span>;<br><br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">ctor: <span class="hljs-keyword">new</span> (...args: <span class="hljs-built_in">any</span>[]) =&gt; T, staticArguments: <span class="hljs-built_in">any</span>[] = [], supportsDelayedInstantiation: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span></span>)</span> &#123;<br><span class="hljs-built_in">this</span>.ctor = ctor;<span class="hljs-comment">//服务的构造器</span><br><span class="hljs-built_in">this</span>.staticArguments = staticArguments;<span class="hljs-comment">// 静态参数</span><br><span class="hljs-built_in">this</span>.supportsDelayedInstantiation = supportsDelayedInstantiation;<span class="hljs-comment">// 是否支持延迟实例化</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SyncDescriptor 是一个用于包装需要被容器实例化容器的描述符对象，它保存了对象的构造器和静态参数</p><h2 id="实例化容器"><a href="#实例化容器" class="headerlink" title="实例化容器"></a>实例化容器</h2><p>上文讲到，我们创建了一个服务集容器，并把服务注入到了容器之中，那么就需要一个类来操作这个容器， InstantiationService 这个类就是起到这个作用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> IInstantiationService = createDecorator&lt;IInstantiationService&gt;(<span class="hljs-string">&#x27;instantiationService&#x27;</span>);<br>从源码中，我们也能看到，IInstantiationService 也是一个服务，他最早在 main.ts 中的 startup 函数中被初始化。<br><br><span class="hljs-keyword">const</span> instantiationService = <span class="hljs-keyword">new</span> InstantiationService(services, <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>在创建了 instantiationService 实例之后，可调用 invokeFunction 方法来手动地获取服务实例，容器会自动去分析它所依赖的服务并自动实例化后返回。在寻找容器中的服务时，当在当前容器中找不到这个服务时，会去查找父容器中是否有这个服务。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts">_getServiceInstanceOrDescriptor&lt;T&gt;(id: ServiceIdentifier&lt;T&gt;): T | SyncDescriptor&lt;T&gt; &#123;<br><span class="hljs-comment">// 在容器中根据 id 获取服务实例或描述符</span><br><span class="hljs-keyword">let</span> instanceOrDesc = <span class="hljs-built_in">this</span>._services.get(id);<br><span class="hljs-keyword">if</span> (!instanceOrDesc &amp;&amp; <span class="hljs-built_in">this</span>._parent) &#123;<br><span class="hljs-comment">// 查找父容器的服务</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._parent._getServiceInstanceOrDescriptor(id);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> instanceOrDesc;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果找到的服务是个 SyncDescriptor，即这个服务还依赖其他服务，则会通过图的关系来处理服务间的依赖关系，这里是整个依赖注入的核心，放到下面详细说明。</p><h2 id="依赖分析"><a href="#依赖分析" class="headerlink" title="依赖分析"></a>依赖分析</h2><p>在上文中讲到，在不依赖其他服务的情况下，是很简单的。当服务之间有依赖关系，随着需求的增加就会变得十分复杂。而依赖注入的核心就是这些关系的处理，以及查看存在的依赖循环，那么 vscode 是如何处理这些依赖关系的呢，让我们看下面这段代码，可能比较复杂，我们慢慢分析。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs ts">_createAndCacheServiceInstance&lt;T&gt;(id: ServiceIdentifier&lt;T&gt;, desc: SyncDescriptor&lt;T&gt;, _trace: Trace): T &#123;<br><br><span class="hljs-keyword">type</span> Triple = &#123; <span class="hljs-attr">id</span>: ServiceIdentifier&lt;<span class="hljs-built_in">any</span>&gt;, desc: SyncDescriptor&lt;<span class="hljs-built_in">any</span>&gt;, _trace: Trace; &#125;;<br><span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> Graph&lt;Triple&gt;(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> data.id.toString());<br><br><span class="hljs-keyword">let</span> cycleCount = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 将当前依赖推入栈</span><br><span class="hljs-keyword">const</span> stack = [&#123; id, desc, _trace &#125;];<br>  <span class="hljs-comment">// 根据依赖关系构造有向图</span><br><span class="hljs-keyword">while</span> (stack.length) &#123;<br><span class="hljs-keyword">const</span> item = stack.pop()!;<br>    <span class="hljs-comment">// 查找或者插入节点 graph: myService, (incoming)[], (outgoing)[]</span><br>graph.lookupOrInsertNode(item);<br><br><span class="hljs-comment">// a weak but working heuristic for cycle checks</span><br><span class="hljs-keyword">if</span> (cycleCount++ &gt; <span class="hljs-number">1000</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CyclicDependencyError(graph);<br>&#125;<br><br><span class="hljs-comment">// 检查所有依赖项是否存在以及是否需要首先创建它们， dependency 是我们服务所依赖的其他服务</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> dependency <span class="hljs-keyword">of</span> _util.getServiceDependencies(item.desc.ctor)) &#123;<br><br><span class="hljs-keyword">let</span> instanceOrDesc = <span class="hljs-built_in">this</span>._getServiceInstanceOrDescriptor(dependency.id);<br><span class="hljs-keyword">if</span> (!instanceOrDesc &amp;&amp; !dependency.optional) &#123;<br><span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`[createInstance] <span class="hljs-subst">$&#123;id&#125;</span> depends on <span class="hljs-subst">$&#123;dependency.id&#125;</span> which is NOT registered.`</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (instanceOrDesc <span class="hljs-keyword">instanceof</span> SyncDescriptor) &#123;<br><span class="hljs-keyword">const</span> d = &#123; <span class="hljs-attr">id</span>: dependency.id, <span class="hljs-attr">desc</span>: instanceOrDesc, <span class="hljs-attr">_trace</span>: item._trace.branch(dependency.id, <span class="hljs-literal">true</span>) &#125;;<br>graph.insertEdge(item, d);<br>stack.push(d);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-keyword">const</span> roots = graph.roots();<br><br><span class="hljs-comment">// 所有 outgoing 为空但是还有节点时，认为是有依赖循环，报错</span><br><span class="hljs-keyword">if</span> (roots.length === <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (!graph.isEmpty()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CyclicDependencyError(graph);<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> &#123; data &#125; <span class="hljs-keyword">of</span> roots) &#123;<br><span class="hljs-comment">// Repeat the check for this still being a service sync descriptor. That&#x27;s because</span><br><span class="hljs-comment">// instantiating a dependency might have side-effect and recursively trigger instantiation</span><br><span class="hljs-comment">// so that some dependencies are now fullfilled already.</span><br><span class="hljs-keyword">const</span> instanceOrDesc = <span class="hljs-built_in">this</span>._getServiceInstanceOrDescriptor(data.id);<br><span class="hljs-keyword">if</span> (instanceOrDesc <span class="hljs-keyword">instanceof</span> SyncDescriptor) &#123;<br><span class="hljs-comment">// 创建实例</span><br><span class="hljs-keyword">const</span> instance = <span class="hljs-built_in">this</span>._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);<br><span class="hljs-built_in">this</span>._setServiceInstance(data.id, instance);<br>&#125;<br>graph.removeNode(data);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> &lt;T&gt;<span class="hljs-built_in">this</span>._getServiceInstanceOrDescriptor(id);<br>&#125;<br></code></pre></td></tr></table></figure><p>vscode 是通过图来保存依赖间的关系，我们的依赖关系可以看做是一个有向图，不同的依赖可以看做是图中的一个节点，而节点间实例化的先后顺序可以看做图的边，在 vscode 中，是采用邻接表这种数据结构来表示图，即Graph 中用一个 _nodes 来保存每个顶点，且每个顶点的所有相邻（出度及入度）顶点保存在顶点对应的一张链表中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts">insertEdge(<span class="hljs-keyword">from</span>: T, <span class="hljs-attr">to</span>: T): <span class="hljs-built_in">void</span> &#123;<br><span class="hljs-keyword">const</span> fromNode = <span class="hljs-built_in">this</span>.lookupOrInsertNode(<span class="hljs-keyword">from</span>);<br><span class="hljs-keyword">const</span> toNode = <span class="hljs-built_in">this</span>.lookupOrInsertNode(to);<br><br>fromNode.outgoing.set(<span class="hljs-built_in">this</span>._hashFn(to), toNode);<br>toNode.incoming.set(<span class="hljs-built_in">this</span>._hashFn(<span class="hljs-keyword">from</span>), fromNode);<br>&#125;<br></code></pre></td></tr></table></figure><p>有向图构造完之后，从图中拿出所有出度构成的依赖数组，因为依赖关系是逐层往上的，即将 A 服务所依赖的其他服务依次实例化，最后再实例化 A ，一直到全部实例化完成为止。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-comment">// 出度，即本服务依赖的服务数组</span><br><span class="hljs-keyword">const</span> roots = graph.roots();<br><br><span class="hljs-comment">// 根节点为空但是图中不为空时，报错</span><br><span class="hljs-keyword">if</span> (roots.length === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 如果所有依赖都已经实例化完成而图中还有节点则认为包含循环依赖</span><br><span class="hljs-keyword">if</span> (!graph.isEmpty()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CyclicDependencyError(graph);<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>    <span class="hljs-comment">// 遍历数组并以此实例化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> &#123; data &#125; <span class="hljs-keyword">of</span> roots) &#123;<br><span class="hljs-comment">// Repeat the check for this still being a service sync descriptor. That&#x27;s because</span><br><span class="hljs-comment">// instantiating a dependency might have side-effect and recursively trigger instantiation</span><br><span class="hljs-comment">// so that some dependencies are now fullfilled already.</span><br><span class="hljs-keyword">const</span> instanceOrDesc = <span class="hljs-built_in">this</span>._getServiceInstanceOrDescriptor(data.id);<br><span class="hljs-keyword">if</span> (instanceOrDesc <span class="hljs-keyword">instanceof</span> SyncDescriptor) &#123;<br><span class="hljs-comment">// 创建实例</span><br><span class="hljs-keyword">const</span> instance = <span class="hljs-built_in">this</span>._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);<br><span class="hljs-built_in">this</span>._setServiceInstance(data.id, instance);<br>&#125;<br>graph.removeNode(data);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> &lt;T&gt;<span class="hljs-built_in">this</span>._getServiceInstanceOrDescriptor(id);<br></code></pre></td></tr></table></figure><p>当所有实例化全部完成，调用栈回到 _createInstance 方法，serviceArags 拿到了所有的依赖后调用 create 方法传入构造器以及其参数创建实例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">private</span> _createInstance&lt;T&gt;(ctor: <span class="hljs-built_in">any</span>, <span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[] = [], <span class="hljs-attr">_trace</span>: Trace): T &#123;<br><br><span class="hljs-comment">// 由服务装饰器定义的参数，根据 index 排序</span><br><span class="hljs-keyword">let</span> serviceDependencies = _util.getServiceDependencies(ctor).sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.index - b.index);<br><span class="hljs-keyword">let</span> serviceArgs: <span class="hljs-built_in">any</span>[] = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dependency <span class="hljs-keyword">of</span> serviceDependencies) &#123;<br><span class="hljs-comment">// 获取或者创建实例</span><br><span class="hljs-keyword">let</span> service = <span class="hljs-built_in">this</span>._getOrCreateServiceInstance(dependency.id, _trace);<br><span class="hljs-keyword">if</span> (!service &amp;&amp; <span class="hljs-built_in">this</span>._strict &amp;&amp; !dependency.optional) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`[createInstance] <span class="hljs-subst">$&#123;ctor.name&#125;</span> depends on UNKNOWN service <span class="hljs-subst">$&#123;dependency.id&#125;</span>.`</span>);<br>&#125;<br>serviceArgs.push(service);<br>&#125;<br><br><span class="hljs-keyword">let</span> firstServiceArgPos = serviceDependencies.length &gt; <span class="hljs-number">0</span> ? serviceDependencies[<span class="hljs-number">0</span>].index : args.length;<br><br><span class="hljs-comment">// check for argument mismatches, adjust static args if needed</span><br><span class="hljs-keyword">if</span> (args.length !== firstServiceArgPos) &#123;<br><span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`[createInstance] First service dependency of <span class="hljs-subst">$&#123;ctor.name&#125;</span> at position <span class="hljs-subst">$&#123;firstServiceArgPos + <span class="hljs-number">1</span>&#125;</span> conflicts with <span class="hljs-subst">$&#123;args.length&#125;</span> static arguments`</span>);<br><br><span class="hljs-keyword">let</span> delta = firstServiceArgPos - args.length;<br><span class="hljs-keyword">if</span> (delta &gt; <span class="hljs-number">0</span>) &#123;<br>args = args.concat(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(delta));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>args = args.slice(<span class="hljs-number">0</span>, firstServiceArgPos);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 创建服务实例</span><br><span class="hljs-keyword">return</span> &lt;T&gt;<span class="hljs-keyword">new</span> ctor(...[...args, ...serviceArgs]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文从 vscode 源码的角度分析了其依赖注入的原理，简而言之，依赖分析的过程是递归向下获取所有的依赖项，再递归向上优先实例化最底层的依赖，在实例化依赖的时候，会逐级去查找依赖并实例化。用服务集容器来管理依赖，可以让每个服务集容器具有不同的能力，例如在 vscode 中，主进程和渲染进程并不共享一套服务，因为主进程和渲染进程的能力和职责不同，分开管理比较合理。</p>]]></content>
    
    
    <categories>
      
      <category>vscode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链表介绍</title>
    <link href="/2021/07/05/link-introduction/"/>
    <url>/2021/07/05/link-introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><p>底层的存储结构：</p><p>从图中我们看到，数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。</p><p>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。</p><img src="https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg"><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作后继指针 next。</p><img src="https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg"><p>从单链表图中，你应该可以发现，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。</p><p>与数组一样，链表也支持数据的查找、插入和删除操作。</p><p>我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p><img src="https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg"><p>从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</p><p>但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表是一种特殊的单链表。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。</p><img src="https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg"><p>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p><img src="https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg"><p>从图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？</p><p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p><ul><li><p>删除操作</p><p>  在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul><li>删除结点中“值等于某个给定值”的结点；</li><li>删除给定指针指向的结点。</li></ul><p>  对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。</p><p>  尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</p><p>  对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。</p><p>  但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！</p><p>  同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。你可以参照我刚刚讲过的删除操作自己分析一下。</p><p>  除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><p>  现在，你有没有觉得双向链表要比单链表更加高效呢？这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。如果你熟悉 Java 语言，你肯定用过 LinkedHashMap 这个容器。如果你深入研究 LinkedHashMap 的实现原理，就会发现其中就用到了双向链表这种数据结构。</p><p>  实际上，这里有一个更加重要的知识点需要你掌握，那就是<code>用空间换时间</code>的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p><p>  对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。</p></li></ul><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><img src="https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg"><h3 id="链表-VS-数组性能大比拼"><a href="#链表-VS-数组性能大比拼" class="headerlink" title="链表 VS 数组性能大比拼"></a>链表 VS 数组性能大比拼</h3><img src="https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg"><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p><p>如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p><h3 id="如何基于链表实现-LRU-缓存淘汰算法"><a href="#如何基于链表实现-LRU-缓存淘汰算法" class="headerlink" title="如何基于链表实现 LRU 缓存淘汰算法"></a>如何基于链表实现 LRU 缓存淘汰算法</h3><p>我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ol><li><p>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p></li><li><p>如果此数据没有在缓存链表中，又可以分为两种情况：</p><ul><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ul></li></ol><p>现在我们来看下缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。</p><p>实际上，我们可以继续优化这个实现思路，比如引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。</p><h3 id="写链表代码技巧"><a href="#写链表代码技巧" class="headerlink" title="写链表代码技巧"></a>写链表代码技巧</h3><h4 id="理解指针或引用的含义"><a href="#理解指针或引用的含义" class="headerlink" title="理解指针或引用的含义"></a>理解指针或引用的含义</h4><p>事实上，看懂链表的结构并不是很难，但是一旦把它和指针混在一起，就很容易让人摸不着头脑。所以，要想写对链表代码，首先就要理解好指针。</p><p>我们知道，有些语言有“指针”的概念，比如 C 语言；有些语言没有指针，取而代之的是“引用”，比如 Java、Python。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址，以下为 C 语言的指针，其他语言自行转换为引用即可。</p><p>实际上，对于指针的理解，你只需要记住下面这句话就可以了：</p><p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p><p>在编写链表代码的时候，我们经常会有这样的代码：p-&gt;next=q。这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。</p><p>还有一个更复杂的，也是我们写链表代码经常会用到的：p-&gt;next=p-&gt;next-&gt;next。这行代码表示，p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址。</p><h4 id="警惕指针丢失和内存泄漏"><a href="#警惕指针丢失和内存泄漏" class="headerlink" title="警惕指针丢失和内存泄漏"></a>警惕指针丢失和内存泄漏</h4><img src="https://static001.geekbang.org/resource/image/05/6e/05a4a3b57502968930d517c934347c6e.jpg"><p>如图所示，我们希望在结点 a 和相邻的结点 b 之间插入结点 x，假设当前指针 p 指向结点 a。如果我们将代码实现变成下面这个样子，就会发生指针丢失和内存泄露。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;next = x;  <span class="hljs-comment">// 将p的next指针指向x结点；</span><br>x-&gt;next = p-&gt;next;  <span class="hljs-comment">// 将x的结点的next指针指向b结点；</span><br></code></pre></td></tr></table></figure><p>p-&gt;next 指针在完成第一步操作之后，已经不再指向结点 b 了，而是指向结点 x。第 2 行代码相当于将 x 赋值给 x-&gt;next，自己指向自己。因此，整个链表也就断成了两半，从结点 b 往后的所有结点都无法访问到了。</p><p>对于有些语言来说，比如 C 语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。所以，我们插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。所以，对于刚刚的插入代码，我们只需要把第 1 行和第 2 行代码的顺序颠倒一下就可以了。</p><p>同理，删除链表结点时，也一定要记得手动释放内存空间，否则，也会出现内存泄漏的问题。当然，对于像 Java 这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。</p><h4 id="利用哨兵简化实现难度"><a href="#利用哨兵简化实现难度" class="headerlink" title="利用哨兵简化实现难度"></a>利用哨兵简化实现难度</h4><p>首先，我们先来回顾一下单链表的插入和删除操作。如果我们在结点 p 后面插入一个新的结点，只需要下面两行代码就可以搞定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">new_node-&gt;next = p-&gt;next;<br>p-&gt;next = new_node;<br></code></pre></td></tr></table></figure><p>但是，当我们要向一个空链表中插入第一个结点，刚刚的逻辑就不能用了。我们需要进行下面这样的特殊处理，其中 head 表示链表的头结点。所以，从这段代码，我们可以发现，对于单链表的插入操作，第一个结点和其他结点的插入逻辑是不一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (head == null) &#123;<br>  head = new_node;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来看单链表结点删除操作。如果要删除结点 p 的后继结点，我们只需要一行代码就可以搞定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;next = p-&gt;next-&gt;next;<br></code></pre></td></tr></table></figure><p>但是，如果我们要删除链表中的最后一个结点，前面的删除代码就不 work 了。跟插入类似，我们也需要对于这种情况特殊处理。写成代码是这样子的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (head-&gt;next == null) &#123;<br>   head = null;<br>&#125;<br></code></pre></td></tr></table></figure><p>从前面的一步一步分析，我们可以看出，针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。如何来解决这个问题呢？</p><p>技巧三中提到的哨兵就要登场了。哨兵，解决的是国家之间的边界问题。同理，这里说的哨兵也是解决“边界问题”的，不直接参与业务逻辑。</p><p>还记得如何表示一个空链表吗？head=null 表示链表中没有结点了。其中 head 表示头结点指针，指向链表中的第一个结点。</p><p>如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。</p><p>如图，你可以发现，哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。</p><img src="https://static001.geekbang.org/resource/image/7d/c7/7d22d9428bdbba96bfe388fe1e3368c7.jpg"><p>实际上，这种利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。现在为了让你感受更深，我再举一个非常简单的例子。代码我是用 C 语言实现的，不涉及语言方面的高级语法，很容易看懂，你可以类比到你熟悉的语言。</p><p>代码一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在数组a中，查找key，返回key所在的位置</span><br><span class="hljs-comment">// 其中，n表示数组a的长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> key)</span> </span>&#123;<br>  <span class="hljs-comment">// 边界条件处理，如果a为空，或者n&lt;=0，说明数组中没有数据，就不用while循环比较了</span><br>  <span class="hljs-keyword">if</span>(a == null || n &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 这里有两个比较操作：i&lt;n和a[i]==key.</span><br>  <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>    <span class="hljs-keyword">if</span> (a[i] == key) &#123;<br>      <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    ++i;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在数组a中，查找key，返回key所在的位置</span><br><span class="hljs-comment">// 其中，n表示数组a的长度</span><br><span class="hljs-comment">// 我举2个例子，你可以拿例子走一下代码</span><br><span class="hljs-comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;  n=6 key = 7</span><br><span class="hljs-comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;  n=6 key = 6</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> key)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span>(a == null || n &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值</span><br>  <span class="hljs-keyword">if</span> (a[n<span class="hljs-number">-1</span>] == key) &#123;<br>    <span class="hljs-keyword">return</span> n<span class="hljs-number">-1</span>;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。</span><br>  <span class="hljs-comment">// 之所以这样做的目的是：希望find()代码不要改变a数组中的内容</span><br>  <span class="hljs-keyword">char</span> tmp = a[n<span class="hljs-number">-1</span>];<br>  <span class="hljs-comment">// 把key的值放到a[n-1]中，此时a = &#123;4, 2, 3, 5, 9, 7&#125;</span><br>  a[n<span class="hljs-number">-1</span>] = key;<br>  <br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// while 循环比起代码一，少了i&lt;n这个比较操作</span><br>  <span class="hljs-keyword">while</span> (a[i] != key) &#123;<br>    ++i;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 恢复a[n-1]原来的值,此时a= &#123;4, 2, 3, 5, 9, 6&#125;</span><br>  a[n<span class="hljs-number">-1</span>] = tmp;<br>  <br>  <span class="hljs-keyword">if</span> (i == n<span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-comment">// 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 否则，返回i，就是等于key值的元素的下标</span><br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对比两段代码，在字符串 a 很长的时候，比如几万、几十万，你觉得哪段代码运行得更快点呢？答案是代码二，因为两段代码中执行次数最多就是 while 循环那一部分。第二段代码中，我们通过一个哨兵 a[n-1] = key，成功省掉了一个比较语句 i</p><p>当然，这只是为了举例说明哨兵的作用，你写代码的时候千万不要写第二段那样的代码，因为可读性太差了。大部分情况下，我们并不需要如此追求极致的性能。</p><h4 id="重点留意边界条件处理"><a href="#重点留意边界条件处理" class="headerlink" title="重点留意边界条件处理"></a>重点留意边界条件处理</h4><p>软件开发中，代码在一些边界或者异常情况下，最容易产生 Bug。链表代码也不例外。要实现没有 Bug 的链表代码，一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。</p><p>可参考以下几个方面：</p><ul><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个结点时，代码是否能正常工作？</li><li>如果链表只包含两个结点时，代码是否能正常工作？</li><li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li></ul><h4 id="举例画图，辅助思考"><a href="#举例画图，辅助思考" class="headerlink" title="举例画图，辅助思考"></a>举例画图，辅助思考</h4><p>对于稍微复杂的链表操作，比如前面我们提到的单链表反转，指针一会儿指这，一会儿指那，一会儿就被绕晕了。总感觉脑容量不够，想不清楚。所以这个时候就要使用大招了，举例法和画图法。</p><p>你可以找一个具体的例子，把它画在纸上，释放一些脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。比如往单链表中插入一个数据这样一个操作，我一般都是把各种情况都举一个例子，画出插入前和插入后的链表变化，如图所示：</p><img src="https://static001.geekbang.org/resource/image/4a/f8/4a701dd79b59427be654261805b349f8.jpg"><p>转自 《数据结构与算法之美》</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组介绍</title>
    <link href="/2021/07/05/array-introduction/"/>
    <url>/2021/07/05/array-introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p><ul><li><p>线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p>  <img src="https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg"/><p>  与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p>  <img src="https://static001.geekbang.org/resource/image/6e/69/6ebf42641b5f98f912d36f6bf86f6569.jpg"/></li><li><p>连续的内存空间和相同类型的数据。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p></li></ul><h3 id="数组是如何实现根据下标随机访问数组元素的"><a href="#数组是如何实现根据下标随机访问数组元素的" class="headerlink" title="数组是如何实现根据下标随机访问数组元素的"></a>数组是如何实现根据下标随机访问数组元素的</h3><p>拿一个长度为 10 的 int 类型的数组 int[] a = new int[10]来举例。在我画的这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p><img src="https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg"><p>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">a[i]_address = base_address + i * data_type_size<br></code></pre></td></tr></table></figure><p>其中 data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。</p><p>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。</p><h3 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h3><ul><li>插入操作</li></ul><p>假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？</p><p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。</p><p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</p><p>举一个例子。假设数组 a[10]中存储了如下 5 个元素：a，b，c，d，e。</p><p>我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2]赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。</p><img src="https://static001.geekbang.org/resource/image/3f/dc/3f70b4ad9069ec568a2caaddc231b7dc.jpg"><p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。</p><ul><li>删除操作</li></ul><p>跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。</p><p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p><p>举个例子，数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p><img src="https://static001.geekbang.org/resource/image/b6/e5/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg"><p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p><h3 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(; i&lt;=<span class="hljs-number">3</span>; i++)&#123;<br>        arr[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？</p><p>因为，数组大小为 3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致 for 循环的结束条件错写为了 i&lt;=3 而非 i&lt;3，所以当 i=3 时，数组 a[3]访问越界。</p><p>在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。</p><h3 id="容器能否完全替代数组？"><a href="#容器能否完全替代数组？" class="headerlink" title="容器能否完全替代数组？"></a>容器能否完全替代数组？</h3><p>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。</p><p>如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。</p><p>不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。</p><h3 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h3><ul><li><p>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</p></li><li><p>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</p></li><li><p>还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList &gt; array。</p></li></ul><h3 id="为什么数组要从-0-开始编号而不是-1-？"><a href="#为什么数组要从-0-开始编号而不是-1-？" class="headerlink" title="为什么数组要从 0 开始编号而不是 1 ？"></a>为什么数组要从 0 开始编号而不是 1 ？</h3><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">a[k]_address = base_address + k * type_size<br></code></pre></td></tr></table></figure><p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">a[k]_address = base_address + (k<span class="hljs-number">-1</span>)*type_size<br></code></pre></td></tr></table></figure><p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p><p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p><p>上面解释得再多其实都算不上压倒性的证明，说数组起始编号非 0 开始不可。所以我觉得最主要的原因可能是历史原因。</p><p>C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。</p><p>转自《数据结构与算法之美》</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>均摊时间复杂度</title>
    <link href="/2021/07/05/amortized-time-complexity/"/>
    <url>/2021/07/05/amortized-time-complexity/</url>
    
    <content type="html"><![CDATA[<h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// array表示一个长度为n的数组</span><br><span class="hljs-comment">// 代码中的array.length就等于n</span><br><span class="hljs-keyword">int</span>[] <span class="hljs-built_in">array</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (count == <span class="hljs-built_in">array</span>.length) &#123;<br>      <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">array</span>.length; ++i) &#123;<br>         sum = sum + <span class="hljs-built_in">array</span>[i];<br>      &#125;<br>      <span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] = sum;<br>      count = <span class="hljs-number">1</span>;<br>   &#125;<br><br>   <span class="hljs-built_in">array</span>[count] = val;<br>   ++count;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p><p>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p><p>那平均时间复杂度是多少呢？答案是 O(1)。我们还是可以通过前面讲的概率论的方法来分析。</p><p>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：</p><img src="https://static001.geekbang.org/resource/image/6d/ed/6df62366a60336d9de3bc34f488d8bed.jpg"/><h3 id="摊还分析法"><a href="#摊还分析法" class="headerlink" title="摊还分析法"></a>摊还分析法</h3><p>find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()第一个区别于 find() 的地方。</p><p>我们再来看第二个不同的地方。对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</p><p>所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。</p><p>针对这种特殊的场景，我们引入了一种更加简单的分析方法：摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度。</p><p>那究竟如何使用摊还分析法来分析算法的均摊时间复杂度呢？</p><p>我们还是继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。</p><p>均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。为了方便你理解、记忆，我这里简单总结一下它们的应用场景。如果你遇到了，知道是怎么回事儿就行了。</p><p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p><p>尽管很多数据结构和算法书籍都花了很大力气来区分平均时间复杂度和均摊时间复杂度，但其实我个人认为，均摊时间复杂度就是一种特殊的平均时间复杂度，我们没必要花太多精力去区分它们。你最应该掌握的是它的分析方法，摊还分析。至于分析出来的结果是叫平均还是叫均摊，这只是个说法，并不重要。</p><p>转自《数据结构与算法之美》</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最好、最坏、平均情况时间复杂度</title>
    <link href="/2021/07/05/some-time-complexity/"/>
    <url>/2021/07/05/some-time-complexity/</url>
    
    <content type="html"><![CDATA[<h2 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// n表示数组array的长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] <span class="hljs-built_in">array</span>, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> pos = <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] == x) pos = i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> pos;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码要实现的功能是，在一个无序的数组（array）中，查找变量 x 出现的位置。如果没有找到，就返回 -1。按照上节课讲的分析方法，这段代码的复杂度是 $O(n)$，其中，n 代表数组的长度。</p><p>我们在数组中查找一个数据，并不需要每次都把整个数组都遍历一遍，因为有可能中途找到就可以提前结束循环了。但是，这段代码写得不够高效。我们可以这样优化一下这段查找代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// n表示数组array的长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] <span class="hljs-built_in">array</span>, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> pos = <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">array</span>[i] == x) &#123;<br>       pos = i;<br>       <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> pos;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候，问题就来了。我们优化完之后，这段代码的时间复杂度还是 O(n) 吗？</p><p>要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。</p><p>为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。</p><h3 id="最好情况时间复杂度"><a href="#最好情况时间复杂度" class="headerlink" title="最好情况时间复杂度"></a>最好情况时间复杂度</h3><p>在最理想的情况下，执行这段代码的时间复杂度。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。</p><h3 id="最坏情况时间复杂度"><a href="#最坏情况时间复杂度" class="headerlink" title="最坏情况时间复杂度"></a>最坏情况时间复杂度</h3><p>在最糟糕的情况下，执行这段代码的时间复杂度。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。</p><h3 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h3><p>好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，我们需要引入另一个概念：平均情况时间复杂度，后面简称为平均时间复杂度。</p><p>要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：</p><img src="https://static001.geekbang.org/resource/image/d8/2f/d889a358b8eccc5bbb90fc16e327a22f.jpg"/><p>我们知道，时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。</p><p>这个结论虽然是正确的，但是计算过程稍微有点儿问题。究竟是什么问题呢？我们刚讲的这 n+1 种情况，出现的概率并不是一样的。</p><p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。</p><p>因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p><img src="https://static001.geekbang.org/resource/image/36/7f/36c0aabdac69032f8a43368f5e90c67f.jpg"/><p>这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。</p><p>引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。</p><p>转自《数据结构与算法之美》</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>空间复杂度介绍</title>
    <link href="/2021/07/05/space-complexity/"/>
    <url>/2021/07/05/space-complexity/</url>
    
    <content type="html"><![CDATA[<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度表示算法的存储空间与数据规模之间的增长关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>  <span class="hljs-keyword">for</span> (i; i &lt;n; ++i) &#123;<br>    a[i] = i * i;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (i = n<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>    print out a[i]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 $O(n)$。</p><p>我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>时间复杂度介绍</title>
    <link href="/2021/07/05/time-complexity/"/>
    <url>/2021/07/05/time-complexity/</url>
    
    <content type="html"><![CDATA[<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="O-1"><a href="#O-1" class="headerlink" title="$O(1)$"></a>$O(1)$</h3><p>首先你必须明确一个概念，$O(1)$ 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 $O(1）$，而不是 $O(3)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> i = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">int</span> j = <span class="hljs-number">6</span>; <br><span class="hljs-keyword">int</span> sum = i + j;<br></code></pre></td></tr></table></figure><p>只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p><h3 id="O-logn-、-O-nlogn"><a href="#O-logn-、-O-nlogn" class="headerlink" title="$O(logn)$、$O(nlogn)$"></a>$O(logn)$、$O(nlogn)$</h3><p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">i=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span> (i &lt;= n)<br>    &#123; <br>        i = i * <span class="hljs-number">2</span>; <br>    &#125;<br></code></pre></td></tr></table></figure><p>根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p><p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：</p><img src="https://static001.geekbang.org/resource/image/9b/9a/9b1c88264e7a1a20b5954be9bc4bec9a.jpg"/><p>所以，我们只要知道 $x$ 值是多少，就知道这行代码执行的次数了。通过 $2x=n$ 求解 $x$ 这个问题我们想高中应该就学过了，我就不多说了。$x=log_2n$，所以，这段代码的时间复杂度就是 $O(log_2n)$。</p><p>现在，我把代码稍微改下，你再看看，这段代码的时间复杂度是多少？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">i=<span class="hljs-number">1</span>; <br><span class="hljs-keyword">while</span> (i &lt;= n) <br>    &#123; <br>        i = i * <span class="hljs-number">3</span>; <br>    &#125;<br></code></pre></td></tr></table></figure><p>根据我刚刚讲的思路，很简单就能看出来，这段代码的时间复杂度为 $O(log_3n)$。</p><p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 $O(logn)$。为什么呢？</p><p>我们知道，对数之间是可以互相转换的，$log_3n$ 就等于 $log_32 * log_2n$，所以 $O(log_3n) = O(C * log_2n)$，其中 $C=log_32$ 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 $O(Cf(n)) = O(f(n))$。所以，$O(log_2n)$ 就等于 $O(log_3n)$。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p><p>如果你理解了我前面讲的 $O(logn)$，那 $O(nlogn)$ 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 $O(logn)$，我们循环执行 n 遍，时间复杂度就是 $O(nlogn)$ 了。而且，$O(nlogn)$ 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 $O(nlogn)$。</p><h3 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="$O(m+n)、O(m*n)$"></a>$O(m+n)、O(m*n)$</h3><p>我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> sum_1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; m; ++i) &#123;<br>    sum_1 = sum_1 + i;<br>  &#125;<br><br>  <span class="hljs-keyword">int</span> sum_2 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; j &lt; n; ++j) &#123;<br>    sum_2 = sum_2 + j;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> sum_1 + sum_2;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 $O(m+n)$。</p><p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：$T1(m) + T2(n) = O(f(m) + g(n))$。但是乘法法则继续有效：$T1(m)*T2(n) = O(f(m) * f(n))$。</p><p>转自《数据结构与算法之美》</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 装饰器</title>
    <link href="/2021/07/03/decorators/"/>
    <url>/2021/07/03/decorators/</url>
    
    <content type="html"><![CDATA[<p>装饰器 是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h3><p>如果我们要定制一个修饰器应用到一个声明上，我们得写一个装饰器工厂函数。 装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p><p>例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">color</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) </span>&#123; <span class="hljs-comment">// 这是一个装饰器工厂</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>&#123; <span class="hljs-comment">//  这是装饰器</span><br>        <span class="hljs-comment">// do something with &quot;target&quot; and &quot;value&quot;...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* obj: 要定义属性的对象。</span><br><span class="hljs-comment">* prop: 要定义或修改的属性的名称或 Symbol 。</span><br><span class="hljs-comment">* descriptor: 要定义或修改的属性描述符。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">Object</span>.defineProperty(obj, prop, descriptor)<br></code></pre></td></tr></table></figure><p>该方法允许精确地添加或修改对象的属性。默认的情况下，使用 Object.defineProperty() 添加的属性值是不可修改(immutable)的。</p><h3 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h3><p>数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。</p><h3 id="存取描述符"><a href="#存取描述符" class="headerlink" title="存取描述符"></a>存取描述符</h3><p>存取描述符是由 getter 函数和setter 函数所描述的属性。</p><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>Reflect是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。</p><p>将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，从 Reflect 对象上可以拿到语言内部的方法。</p><p>修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc) 则会返回 false。</p><p>让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name]，而 Reflect.has(obj, name) 和Reflect.deleteProperty(obj, name) 让它们变成了函数行为。</p><p>Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在Reflect 上获取默认行为。</p><h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>类装饰器应用于类构造函数，可以用来监视，修改或替换类定义</p><p>接口定义：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> ClassDecorator = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">TFunction</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">Function</span>&gt;</span>(target: TFunction) =&gt; TFunction | void;</span><br><span class="xml">类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。</span><br></code></pre></td></tr></table></figure><p>首先，写一个最简单的装饰器：</p><p>decorator.ts :</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helloWorld</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello World!&#x27;</span>)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;target :&#x27;</span>, target.toString())<br>&#125;<br><br><span class="hljs-meta">@helloWorld</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldClass</span> </span>&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;jerome&#x27;</span><br>    <br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I am constructor.&#x27;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I am test method.&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 tsc -p . 编译 ts 文件，生成 js 文件，并用 node 执行这个 js 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node decorator/decorator.js</span> <br>hello World!<br>target : function HelloWorldClass() &#123;<br>        this.name = &#x27;jerome&#x27;;<br>        console.log(&#x27;I am constructor.&#x27;);<br>    &#125;<br></code></pre></td></tr></table></figure><p>由此可见，装饰器在运行时就被执行，target 传递的就是 HelloWorldClass 类的构造函数，也印证了装饰器的定义中，它在运行时被调用，被装饰的声明信息作为参数传入。</p><p>接下来，我们解析一下这个 js 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> __decorate = (<span class="hljs-built_in">this</span> &amp;&amp; <span class="hljs-built_in">this</span>.__decorate) || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">decorators, target, key, desc</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> c = <span class="hljs-built_in">arguments</span>.length,<br>        r = c &lt; <span class="hljs-number">3</span> ? target : desc === <span class="hljs-literal">null</span> ? desc = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(target, key) : desc,<br>        d;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Reflect</span> === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Reflect</span>.decorate === <span class="hljs-string">&quot;function&quot;</span>) r = <span class="hljs-built_in">Reflect</span>.decorate(decorators, target, key, desc);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = decorators.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            <span class="hljs-keyword">if</span> (d = decorators[i]) r = (c &lt; <span class="hljs-number">3</span> ? d(r) : c &gt; <span class="hljs-number">3</span> ? d(target, key, r) : d(target, key)) || r;<br>    <span class="hljs-keyword">return</span> c &gt; <span class="hljs-number">3</span> &amp;&amp; r &amp;&amp; <span class="hljs-built_in">Object</span>.defineProperty(target, key, r), r;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helloWorld</span>(<span class="hljs-params">target</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello World!&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;target :&#x27;</span>, target.toString());<br>&#125;<br><span class="hljs-keyword">var</span> HelloWorldClass = <span class="hljs-comment">/** <span class="hljs-doctag">@class </span>*/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HelloWorldClass</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;jerome&#x27;</span>;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I am constructor.&#x27;</span>);<br>    &#125;<br>    HelloWorldClass.prototype.test = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I am test method.&#x27;</span>);<br>    &#125;;<br>    HelloWorldClass = __decorate([<br>        helloWorld<br>    ], HelloWorldClass);<br>    <span class="hljs-keyword">return</span> HelloWorldClass;<br>&#125;());<br></code></pre></td></tr></table></figure><p>代码太多，让我们分几步来解析：</p><p>@helloWorld 类装饰器解析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> __decorate = (<span class="hljs-built_in">this</span> &amp;&amp; <span class="hljs-built_in">this</span>.__decorate) || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">decorators, target, key, desc</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> c = <span class="hljs-built_in">arguments</span>.length,<br>        r = c &lt; <span class="hljs-number">3</span> ? target : desc === <span class="hljs-literal">null</span> ? desc = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(target, key) : desc,<br>        d;<br>   <span class="hljs-comment">// 如果原生反射可用，使用原生反射触发装饰器</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Reflect</span> === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Reflect</span>.decorate === <span class="hljs-string">&quot;function&quot;</span>) r = <span class="hljs-built_in">Reflect</span>.decorate(decorators, target, key, desc);<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">// 自右向左迭代装饰器</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = decorators.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>          <span class="hljs-comment">// 如果装饰器合法，将其赋值给 d</span><br>            <span class="hljs-keyword">if</span> (d = decorators[i]) r = (c &lt; <span class="hljs-number">3</span> ? d(r) : c &gt; <span class="hljs-number">3</span> ? d(target, key, r) : d(target, key)) || r;<br>  <span class="hljs-keyword">return</span> c &gt; <span class="hljs-number">3</span> &amp;&amp; r &amp;&amp; <span class="hljs-built_in">Object</span>.defineProperty(target, key, r), r;<br>&#125;;<br></code></pre></td></tr></table></figure><p>第一行定义了 __decorate 函数，就是通过 @helloWorld 解析出来的，用来处理装饰器的功能。</p><p>这个函数有四个参数，让我们来看看都是些什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * decorators: 数组，包含多个装饰器</span><br><span class="hljs-comment">  * target: 被装饰的类，即 HelloWorldClass 的构造函数</span><br><span class="hljs-comment">  * key: 变量名称</span><br><span class="hljs-comment">  * desc: 属性描述符</span><br><span class="hljs-comment">*/</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">decorators, target, key, desc</span>) </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>c &lt; 3 ? 为什么是 3，c 代表的是传入参数的个数，如果未传入属性描述符，r 都为 target，若传入属性描述符且不为空，则 r 为属性描述符。</p><p>通过对这段 js 的分析之后，可以简化为如下：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> c = <span class="hljs-number">2</span>, r = target, d;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = decorators.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>   <span class="hljs-keyword">if</span> (d = decorators[i]) r = d(r) || r;<br>   <span class="hljs-keyword">return</span> r;<br></code></pre></td></tr></table></figure><p>当装饰器合法时，将其赋值给 d，r = d(r) || r 相当于把 target 作为参数调用装饰器函数的结果赋值给 r, 如果 d(r) 没有返回值，返回的是原来的类 target，当有返回值的时候，返回的是 d(r) 的 return 内容。</p><p>HelloWorldClass 类</p><p>从打包出的结果来看，类 HelloWorld 被解析成了一个自执行函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> HelloWorldClass = <span class="hljs-comment">/** <span class="hljs-doctag">@class </span>*/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HelloWorldClass</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;jerome&#x27;</span>;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I am constructor.&#x27;</span>);<br>  &#125;<br>  HelloWorldClass.prototype.test = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I am test method.&#x27;</span>);<br>  &#125;;<br>  HelloWorldClass = __decorate([<br>      helloWorld<br>  ], HelloWorldClass);<br>  <span class="hljs-keyword">return</span> HelloWorldClass;<br>&#125;());<br></code></pre></td></tr></table></figure><p>在自执行函数中，HelloWorldClass 接收 __decorate() 函数的执行结果，相当于改变了构造函数，所以可以利用装饰器修改类的功能。</p><h2 id="带返回值的类装饰器"><a href="#带返回值的类装饰器" class="headerlink" title="带返回值的类装饰器"></a>带返回值的类装饰器</h2><p>上面的例子是没有返回值的装饰器函数，它返回的是原来的类，那么带返回值的装饰器函数是怎么样的呢？是否是被装饰器修改之后的类呢？让我们来一起探究一下：</p><p>按照之前的步骤，这次我们的装饰器要带有返回值，下面是一个 override 构造函数的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">classDecorator</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> </span>&#123;<span class="hljs-keyword">new</span>(...args:any[]):&#123;&#125;&#125;&gt;(<span class="hljs-title">constructor</span>:<span class="hljs-title">T</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">constructor</span> </span>&#123;<br>        newProperty = <span class="hljs-string">&quot;new property&quot;</span>;<br>        hello = <span class="hljs-string">&quot;override&quot;</span>;<br>    &#125;<br>&#125;<br><br>@classDecorator<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>    property = <span class="hljs-string">&quot;property&quot;</span>;<br>    hello: string;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">m: string</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.hello = m;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">&quot;world&quot;</span>));<br></code></pre></td></tr></table></figure><p>运行的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node decorator/decoratorReturn.js</span> <br>class_1 &#123;<br>property: &#x27;property&#x27;,<br>hello: &#x27;override&#x27;,<br>newProperty: &#x27;new property&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p>由代码可知，Greeter 的构造函数是对 hello 的赋值为 world，然而在使用了 @classDecorator 这个构造函数之后，hello 的值变为了 override, 说明了类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。</p><h2 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h2><p>属性装饰器声明在一个属性声明之前，属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：</p><p>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象<br>成员的名字。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> PropertyDecorator =<br>  <span class="hljs-function">(<span class="hljs-params">target: <span class="hljs-built_in">Object</span>, propertyKey: <span class="hljs-built_in">string</span> | symbol</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br></code></pre></td></tr></table></figure><p>那么，如何理解呢，让我们来看段代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logParameter</span>(<span class="hljs-params">target: <span class="hljs-built_in">Object</span>, propertyName: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-comment">// 属性值</span><br>    <span class="hljs-keyword">let</span> _val = <span class="hljs-built_in">this</span>[propertyName];<br><br>    <span class="hljs-comment">// 属性读取访问器</span><br>    <span class="hljs-keyword">const</span> getter = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Get: <span class="hljs-subst">$&#123;propertyName&#125;</span> =&gt; <span class="hljs-subst">$&#123;_val&#125;</span>`</span>);<br>        <span class="hljs-keyword">return</span> _val;<br>    &#125;;<br><br>    <span class="hljs-comment">// 属性写入访问器</span><br>    <span class="hljs-keyword">const</span> setter = <span class="hljs-function"><span class="hljs-params">newVal</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Set: <span class="hljs-subst">$&#123;propertyName&#125;</span> =&gt; <span class="hljs-subst">$&#123;newVal&#125;</span>`</span>);<br>        _val = newVal;<br>    &#125;;<br><br>    <span class="hljs-comment">// 删除属性</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>[propertyName]) &#123;<br>        <span class="hljs-comment">// 创建新属性及其读取访问器、写入访问器</span><br>        <span class="hljs-built_in">Object</span>.defineProperty(target, propertyName, &#123;<br>            <span class="hljs-attr">get</span>: getter,<br>            <span class="hljs-attr">set</span>: setter,<br>            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>    <span class="hljs-meta">@logParameter</span><br>    <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> greeter = <span class="hljs-keyword">new</span> Greeter();<br>greeter.greeting = <span class="hljs-string">&#x27;Jerome&#x27;</span>;<br>greeter.greeting<br></code></pre></td></tr></table></figure><p>运行这段代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node decorator/prototype.js</span> <br>Set: greeting =&gt; Jerome<br>Get: greeting =&gt; Jerome<br></code></pre></td></tr></table></figure><p>从结果可知，在实例中使用了 getter 和 setter 方法之后，都会打印出相应的 log，即装饰器的表达式在运行的时候被调用了。</p><p>让我们来看看编译成 js 之后的 Greeter 类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> Greeter = <span class="hljs-comment">/** <span class="hljs-doctag">@class </span>*/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params"></span>) </span>&#123;<br>    &#125;<br>    __decorate([<br>        logParameter,<br>        __metadata(<span class="hljs-string">&quot;design:type&quot;</span>, <span class="hljs-built_in">String</span>)<br>    ], Greeter.prototype, <span class="hljs-string">&quot;greeting&quot;</span>, <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> Greeter;<br>&#125;());<br></code></pre></td></tr></table></figure><p>由此可见，此次 __decorate 函数传入了 4 个参数，由在类装饰器分析的 _decorate 函数可知：</p><p>​ 从右往左运行装饰器，先运行__metadata(“design:type”, String) 表示被装饰的参数 greeting 是 String 类型，再运行 logParameter 装饰器，改写 greeting 参数的 getter 和 setter 方法。</p><h2 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h2><p>方法装饰器声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的 属性描述符上，可以用来监视，修改或者替换方法定义。</p><p>方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p><p>target：对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</p><p>propertyKey：成员的名字。</p><p>descriptor：成员的属性描述符。</p><p>同样地，让我们来看段代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logMethod</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">    target: <span class="hljs-built_in">Object</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    propertyName: <span class="hljs-built_in">string</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    propertyDescriptor: PropertyDescriptor</span>): <span class="hljs-title">PropertyDescriptor</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> method = propertyDescriptor.value;<br><br>    propertyDescriptor.value = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>) </span>&#123;<br>        <span class="hljs-comment">// 将 greet 的参数列表转换为字符串</span><br>        <span class="hljs-keyword">const</span> params = args.map(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.stringify(a)).join();<br>        <span class="hljs-comment">// 调用 greet() 并获取其返回值</span><br>        <span class="hljs-keyword">const</span> result = method.apply(<span class="hljs-built_in">this</span>, args);<br>        <span class="hljs-comment">// 转换结尾为字符串</span><br>        <span class="hljs-keyword">const</span> r = <span class="hljs-built_in">JSON</span>.stringify(result);<br>        <span class="hljs-comment">// 在终端显示函数调用细节</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Call: <span class="hljs-subst">$&#123;propertyName&#125;</span>(<span class="hljs-subst">$&#123;params&#125;</span>) =&gt; <span class="hljs-subst">$&#123;r&#125;</span>`</span>);<br>        <span class="hljs-comment">// 返回调用函数的结果</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">return</span> propertyDescriptor;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span></span>)</span> &#123; &#125;<br><br>    <span class="hljs-meta">@logMethod</span><br>    greet(message: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> says: <span class="hljs-subst">$&#123;message&#125;</span>`</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> greeter = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">&#x27;Jerome&#x27;</span>);<br>greeter.greet(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br></code></pre></td></tr></table></figure><p>运行这段代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node decorator/method.js</span> <br>Call: greet(&quot;Hello&quot;) =&gt; &quot;Jerome says: Hello&quot;<br></code></pre></td></tr></table></figure><p>由打印结果可知，logMethod 这个方法装饰器在运行时当作了函数被调用。该函数有利于内审方法的调用，符合面向切面编程的思想。</p><p>让我们来看看编译成 js 之后的 Greeter 类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> Greeter = <span class="hljs-comment">/** <span class="hljs-doctag">@class </span>*/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">name</span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    Greeter.prototype.greet = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot; says: &quot;</span> + message;<br>    &#125;;<br>    __decorate([<br>        logMethod,<br>        __metadata(<span class="hljs-string">&quot;design:type&quot;</span>, <span class="hljs-built_in">Function</span>),<br>        __metadata(<span class="hljs-string">&quot;design:paramtypes&quot;</span>, [<span class="hljs-built_in">String</span>]),<br>        __metadata(<span class="hljs-string">&quot;design:returntype&quot;</span>, <span class="hljs-built_in">String</span>)<br>    ], Greeter.prototype, <span class="hljs-string">&quot;greet&quot;</span>, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">return</span> Greeter;<br>&#125;());<br></code></pre></td></tr></table></figure><p>由此可见，此次 __decorate 函数传入了 4 个参数，由在类装饰器分析的 _decorate 函数可知：</p><p>​ 从右往左运行装饰器，先运行__metadata(“design:returntype”, String) 表示被装饰的方法 greet 的返回值的属性是 String 类型， __metadata(“design:paramtypes”, [String]) 表示方法参数的类型是 String，__metadata(“design:type”, Function)表示被装饰的是函数类型，再运行 logMethod 装饰器，打印出了函数调用的细节。</p><h2 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h2><p>参数装饰器声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。</p><p>参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p><p>target：对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</p><p>propertyKey：成员的名字。</p><p>index：参数在函数参数列表中的索引。</p><p>同样地，让我们来看一段代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logParameter</span>(<span class="hljs-params">target: <span class="hljs-built_in">Object</span>, propertyName: <span class="hljs-built_in">string</span>, index: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>    <span class="hljs-comment">// 为相应方法生成元数据键，以储存被装饰的参数的位置</span><br>    <span class="hljs-keyword">const</span> metadataKey = <span class="hljs-string">`log_<span class="hljs-subst">$&#123;propertyName&#125;</span>_parameters`</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(target[metadataKey])) &#123;<br>        target[metadataKey].push(index);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        target[metadataKey] = [index];<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;target =&gt; &#x27;</span>, target)<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>    greet(<span class="hljs-meta">@logParameter</span> message: <span class="hljs-built_in">string</span>, <span class="hljs-attr">middle</span>:<span class="hljs-built_in">string</span>, <span class="hljs-meta">@logParameter</span> name: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> : <span class="hljs-subst">$&#123;message&#125;</span>`</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> greeter = <span class="hljs-keyword">new</span> Greeter();<br>greeter.greet(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;I am middle&#x27;</span>, <span class="hljs-string">&#x27;jerome&#x27;</span>);<br></code></pre></td></tr></table></figure><p>运行打包之后的 js：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node decorator/parameter.js</span> <br>target =&gt;  Greeter &#123; greet: [Function], log_greet_parameters: [ 2 ] &#125;<br>target =&gt;  Greeter &#123; greet: [Function], log_greet_parameters: [ 2, 0 ] &#125;<br></code></pre></td></tr></table></figure><p>可以看到，打印了两个 log，message 和 name 的位置分别是 0 和 2。</p><p>让我们来看看编译成 js 之后的 Greeter 类：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> Greeter = <span class="hljs-comment">/** <span class="hljs-doctag">@class </span>*/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params"></span>) </span>&#123;<br>    &#125;<br>    Greeter.prototype.greet = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message, middle, name</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot; : &quot;</span> + message;<br>    &#125;;<br>    __decorate([<br>        __param(<span class="hljs-number">0</span>, logParameter), __param(<span class="hljs-number">2</span>, logParameter),<br>        __metadata(<span class="hljs-string">&quot;design:type&quot;</span>, <span class="hljs-built_in">Function</span>),<br>        __metadata(<span class="hljs-string">&quot;design:paramtypes&quot;</span>, [<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>]),<br>        __metadata(<span class="hljs-string">&quot;design:returntype&quot;</span>, <span class="hljs-built_in">String</span>)<br>    ], Greeter.prototype, <span class="hljs-string">&quot;greet&quot;</span>, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">return</span> Greeter;<br>&#125;());<br></code></pre></td></tr></table></figure><p>​ 由此可见，此次 _decorate 函数也传入 4 个参数，注意第 4 个参数为 null，这在 _decorate 函数中会使 r 的值有所不同。由前面可知，装饰器从右往左运行，依次确定被装饰对象的返回值类型，参数类型以及自身的类型为 Function，这里有个不一样的 __param() 装饰器，让我们也来了解一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> __param = (<span class="hljs-built_in">this</span> &amp;&amp; <span class="hljs-built_in">this</span>.__param) || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">paramIndex, decorator</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, key</span>) </span>&#123;<br>        decorator(target, key, paramIndex);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可见，他调用了 logParameter 函数，并传入了一个 paramIndex 表示参数的位置。由此，参数装饰器也一目了然了。</p><p>访问器装饰器<br>访问器装饰器应用于访问器的属性描述符，可用于观测、修改、替换访问器的定义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enumerable</span>(<span class="hljs-params">value: <span class="hljs-built_in">boolean</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;decorator - sets the enumeration part of the accessor&#x27;</span>);<br>        descriptor.enumerable = value;<br>    &#125;;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> _age: <span class="hljs-built_in">number</span> = <span class="hljs-number">18</span>;<br>    <span class="hljs-keyword">private</span> _name: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;jerome&#x27;</span>;<br><br>    <span class="hljs-meta">@enumerable</span>(<span class="hljs-literal">false</span>)<br>    <span class="hljs-keyword">get</span> <span class="hljs-title">age</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._age; &#125;<br><br>    <span class="hljs-keyword">set</span> <span class="hljs-title">age</span>(<span class="hljs-params">age: <span class="hljs-built_in">any</span></span>) &#123; <span class="hljs-built_in">this</span>._age = age; &#125;<br><br>    <span class="hljs-meta">@enumerable</span>(<span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">get</span> <span class="hljs-title">name</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name;<br>    &#125;<br><br>    <span class="hljs-keyword">set</span> <span class="hljs-title">name</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-built_in">this</span>._name = name;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> person) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`enumerable property = <span class="hljs-subst">$&#123;prop&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行之后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node decorator/defineObject.js</span> <br>decorator - sets the enumeration part of the accessor<br>decorator - sets the enumeration part of the accessor<br>enumerable property = _age<br>enumerable property = _name<br>enumerable property = name<br></code></pre></td></tr></table></figure><p>上面的例子中，我们定义了两个访问器 name 和 age ，并通过装饰器设置是否将其列入可枚举属性，我们把 age 设置为false， 所以在清单中不会出现 age。</p><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>Reflect Metadata是 ES7 的一个提案，它主要用来在声明的时候添加和读取元数据。</p><p>可以通过 npm 安装这个库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i reflect-metadata --save<br></code></pre></td></tr></table></figure><p>TypeScript 支持为带有装饰器的声明生成元数据。 你需要在命令行或 tsconfig.json 里启用 emitDecoratorMetadata 编译器选项。</p><p>命令行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata<br></code></pre></td></tr></table></figure><p>tsconfig.json：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;ES5&quot;</span>,<br>        <span class="hljs-attr">&quot;experimentalDecorators&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">&quot;emitDecoratorMetadata&quot;</span>: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当启用后，只要 reflect-metadata 库被引入了，设计阶段添加的类型信息可以在运行时使用。元信息反射 API 能够用来以标准方式组织元信息。「反射」的意思是代码可以侦测同一系统中的其他代码（或其自身）。反射在组合/依赖注入、运行时类型断言、测试等使用场景下很有用。</p><p>在这里，我们能够使用之前学过的各类装饰器来修饰你的代码。</p><p>例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;reflect-metadata&quot;</span>;<br><br><span class="hljs-comment">// 【参数装饰器】用来存储被装饰参数的索引</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logParameter</span>(<span class="hljs-params">target: <span class="hljs-built_in">Object</span>, propertyName: <span class="hljs-built_in">string</span>, index: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> indices = <span class="hljs-built_in">Reflect</span>.getMetadata(<span class="hljs-string">`log_<span class="hljs-subst">$&#123;propertyName&#125;</span>_parameters`</span>, target, propertyName) || [];<br>    indices.push(index);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;indices =&gt; &#x27;</span>, indices);<br>    <span class="hljs-built_in">Reflect</span>.defineMetadata(<span class="hljs-string">`log_<span class="hljs-subst">$&#123;propertyName&#125;</span>_parameters`</span>, indices, target, propertyName);<br>&#125;<br><br><span class="hljs-comment">// 【属性装饰器】用来获取属性的运行时类型</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logProperty</span>(<span class="hljs-params">target: <span class="hljs-built_in">Object</span>, propertyName: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">void</span> </span>&#123;<br>    <span class="hljs-comment">// 获取对象属性的设计类型</span><br>    <span class="hljs-keyword">var</span> t = <span class="hljs-built_in">Reflect</span>.getMetadata(<span class="hljs-string">&quot;design:type&quot;</span>, target, propertyName);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;propertyName&#125;</span> type: <span class="hljs-subst">$&#123;t.name&#125;</span>`</span>);<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>    <span class="hljs-meta">@logProperty</span><br>    <span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    greet(<span class="hljs-meta">@logParameter</span> message: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> says: <span class="hljs-subst">$&#123;message&#125;</span>`</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> greeter = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">&#x27;jerome&#x27;</span>);<br>greeter.greet(<span class="hljs-string">&#x27;hello&#x27;</span>);<br></code></pre></td></tr></table></figure><p>design:type 表示被装饰的对象是什么类型<br>design:paramtypes 表示被装饰对象的参数类型<br>design:returntype 表示被装饰对象的返回值属性</p><p>运行这段代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> node decorator/reflect-metadata.js</span> <br>name type: String<br>indices =&gt;  [ 0 ]<br></code></pre></td></tr></table></figure><p>打印出了我们想知道的 name 的类型以及 message 的参数索引。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>typescript 的装饰器本质上提供了被装饰对象 Property Descriptor 的操作，都是在运行的时候被当作函数调用。看了这篇文章，是否觉得 typescript 这个装饰器的特性有点像 java spring 中注解的写法，我们可以利用我们写的装饰器来实现反射、依赖注入，类型断言等，实现在运行中程序对自身进行检查，vscode 就是典型的利用 typescript 的装饰器实现了依赖注入，有兴趣的请关注后续的文章。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>装饰器是扩展 JavaScript 类的建议，TC39 五年来一直在研究装饰方案，有兴趣的可以关注下 TC39 的这个<a href="https://github.com/tc39/proposal-decorators">提案</a>，babel 也实现了该提案，<a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators">具体可查</a>。</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>原型模式</title>
    <link href="/2021/06/27/prototype/"/>
    <url>/2021/06/27/prototype/</url>
    
    <content type="html"><![CDATA[<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>在我们创建的一个函数时，都有一个 prototype（原型）属性，这个属性是一个<strong>指针</strong>，指向<strong>原型对象</strong>，并且所有的原型对象都会自动获得一个 constructor ，下面我们先定义一个函数，并把所有的属性和方法都挂载在函数的 prototype 属性下，并新建两个对象实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br>Person.prototype.name = <span class="hljs-string">&#x27;jerome&#x27;</span><br>Person.prototype.age = <span class="hljs-number">18</span><br>Person.prototype.job = <span class="hljs-string">&#x27;Front End Engineer&#x27;</span><br>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alter(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> Person()<br></code></pre></td></tr></table></figure><p>那么，代码中实际上 Person 构造函数、Person 的原型属性以及 Person 现有的两个实例间的关系是怎么样的呢，让我们看下图：</p><p><img src="https://img-blog.csdnimg.cn/20210503234607875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plcm9tZV83Nzc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>从图中我们可以看到，Person 的 prototype 属性指向了 Person 的原型对象，而原型对象中的 constructor 又指回了 Peron。并且在 Person 的原型下，还有我们定义的属性和方法。再看创建的两个实例，每个实例都有一个内部属性 [[prototype]]（__proto__） 指向了原型对象。</p><h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><p>由于原型模式省略了为构造函数初始化参数这一环节，默认情况下所有的实例都会取得相同的属性值，在一定程度上造成了不便。但是，还有一个更大的问题，是由其共享的本性所导致的，在属性有引用类型的时候，这个问题就比较突出了，让我们看下下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br>Person.prototype = &#123;<br>    <span class="hljs-attr">constrcutor</span>: Person,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jerome&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&#x27;Front End Engineer&#x27;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&#x27;shy&#x27;</span>, <span class="hljs-string">&#x27;faker&#x27;</span>],<br>    <span class="hljs-attr">sayName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        alter(<span class="hljs-built_in">this</span>.name)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> Person()<br><br>person1.friends.push(<span class="hljs-string">&#x27;rookie&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(person1.friends)    <span class="hljs-comment">// &quot;shy,faker,rookie&quot;</span><br><span class="hljs-built_in">console</span>.log(person2.friends)    <span class="hljs-comment">// &quot;shy,faker,rookie&quot;</span><br><span class="hljs-built_in">console</span>.log(person1.friends === person2.friends)    <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>当原型对象中有引用类型的值时，修改引用类型的值，由于他是一个引用（指针），会修改所有实例的这个属性的值，就如上代码，在 person1.friends 增加一个值之后，person1 和 person2 的 friends 都被修改了。</p><h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>由于在使用原型模式时有引用类型会造成的问题，那么可以结合构造函数和原型模式来使用。这个方法我总结了一句话：属性使用构造函数模式（不共享），方法使用原型模式（共享）。让我们来看下下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, job</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.age = age<br>    <span class="hljs-built_in">this</span>.job = job<br>    <span class="hljs-built_in">this</span>.friends = [<span class="hljs-string">&#x27;shy&#x27;</span>, <span class="hljs-string">&#x27;faker&#x27;</span>]<br>&#125;<br><br>Person.prototype = &#123;<br>    <span class="hljs-attr">constrcutor</span>: Person,<br>    <span class="hljs-attr">sayName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        alter(<span class="hljs-built_in">this</span>.name)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;jerome&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;Front End Engineer&#x27;</span>)<br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;the shy&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;gamer&#x27;</span>)<br><br>person1.friends.push(<span class="hljs-string">&#x27;rookie&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(person1.friends)    <span class="hljs-comment">// &quot;shy,faker,rookie&quot;</span><br><span class="hljs-built_in">console</span>.log(person2.friends)    <span class="hljs-comment">// &quot;shy,faker&quot;</span><br><span class="hljs-built_in">console</span>.log(person1.friends === person2.friends)    <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>可以看到，两个实例的 friends 已经不共享了。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.property = <span class="hljs-literal">true</span><br>&#125;<br><br>SuperType.prototype.getSuperValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.property<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.subproperty = <span class="hljs-literal">false</span><br>&#125;<br><br>SubType.prototype = <span class="hljs-keyword">new</span> SuperType()<br><br>SubType.property.getSubValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.subproperty<br>&#125;<br><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> SubType()<br><span class="hljs-built_in">console</span>.log(instance.getSuperValue())   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>我们可以看到，instance 是 SubType 对象，却可以使用 SuperType 的方法，这就是继承了 SuperType ，而继承的实现就是通过创建父函数的实例，并将该实例赋值给子函数的 prototype 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。让我们来看下他们之间的关系：</p><p><img src="https://img-blog.csdnimg.cn/20210503234623313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plcm9tZV83Nzc=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>在上面代码中，我们没有使用 SubType 默认的原型对象，而是使用了 SuperType 的实例当作他的原型。这个原型含有 SuperType 所有的属性和方法。从之前原型对象的知识点可知，实例的内部还有一个指针（[[prototype]]），指向原型，这里相当于是 SubType 的原型对象指向了 SuperType 的原型，这样就实现了继承。</p><h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><p>同样的，原型链也含有引用类型的问题，那么，接下来我将介绍一下如何解决这个问题。</p><h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><p>这个方法的基本思想就是在子类型构造函数的内部通过 call 或者 apply 调用超类型构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.friends = [<span class="hljs-string">&#x27;the shy&#x27;</span>, <span class="hljs-string">&#x27;faker&#x27;</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>&#123;<br>    SuperType.call(<span class="hljs-built_in">this</span>, <span class="hljs-string">&#x27;jerome&#x27;</span>)<br>    <span class="hljs-built_in">this</span>.age = <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-keyword">const</span> instance1 = <span class="hljs-keyword">new</span> SubType()<br>instance1.friends.push(<span class="hljs-string">&#x27;rookie&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(instance1.friends)   <span class="hljs-comment">// [ &#x27;the shy&#x27;, &#x27;faker&#x27;, &#x27;rookie&#x27; ]</span><br><span class="hljs-built_in">console</span>.log(instance1.name)      <span class="hljs-comment">// jerome</span><br><br><span class="hljs-keyword">const</span> instance2 = <span class="hljs-keyword">new</span> SubType()<br><span class="hljs-built_in">console</span>.log(instance2.friends)   <span class="hljs-comment">// [ &#x27;the shy&#x27;, &#x27;faker&#x27; ]</span><br></code></pre></td></tr></table></figure><p>但这个方法存在一个问题，方法都在构造函数中定义，函数复用也无从说起，这个方法很少单独使用。</p><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>组合继承，就是将原型链和借用构造函数的技术组合到一起。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.friends = [<span class="hljs-string">&#x27;the shy&#x27;</span>, <span class="hljs-string">&#x27;faker&#x27;</span>]<br>&#125;<br><br>SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    SuperType.call(<span class="hljs-built_in">this</span>, name)<br>    <span class="hljs-built_in">this</span>.age = age<br>&#125;<br><br><span class="hljs-comment">// 继承方法</span><br>SubType.prototype = <span class="hljs-keyword">new</span> SuperType()<br>SubType.prototype.constructor = SubType<br>SubType.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age)<br>&#125;<br><br><span class="hljs-keyword">const</span> instance1 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&#x27;jerome&#x27;</span>, <span class="hljs-number">18</span>)<br>instance1.friends.push(<span class="hljs-string">&#x27;rookie&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(instance1.friends)  <span class="hljs-comment">// [ &#x27;the shy&#x27;, &#x27;faker&#x27;, &#x27;rookie&#x27; ]</span><br>instance1.sayName() <span class="hljs-comment">// jerome</span><br>instance1.sayAge()  <span class="hljs-comment">// 18</span><br><br><span class="hljs-keyword">const</span> instance2 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&#x27;the shy&#x27;</span>, <span class="hljs-number">19</span>)<br><span class="hljs-built_in">console</span>.log(instance2.friends)  <span class="hljs-comment">// [ &#x27;the shy&#x27;, &#x27;faker&#x27; ]</span><br>instance2.sayName() <span class="hljs-comment">// the shy</span><br>instance2.sayAge()  <span class="hljs-comment">// 19</span><br></code></pre></td></tr></table></figure><p>在这个例子中，可以看到 SubType 继承了 SuperType 的属性和方法，又有自己的属性和方法，并且 friends 属性是相互独立的，避免了原型链（引用类型问题）和借用构造函数（方法无法复用）的缺陷，但组合继承也有缺点，我们后续会说到。</p><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>原型式继承，就是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。可以利用 Object.create() 来实现，这个方法接收两个参数：一个用作新对象原型的对象和一个为新对象定义额外属性的对象（可选）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jerome&#x27;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&#x27;the shy&#x27;</span>, <span class="hljs-string">&#x27;faker&#x27;</span>]<br>&#125;<br><br><span class="hljs-keyword">const</span> anotherPerson = <span class="hljs-built_in">Object</span>.create(person, &#123;<br>    <span class="hljs-attr">name</span>: &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;rookie&#x27;</span><br>    &#125;<br>&#125;)<br><br>anotherPerson.friends.push(<span class="hljs-string">&#x27;zoom&#x27;</span>)  <br><span class="hljs-built_in">console</span>.log(anotherPerson.name)     <span class="hljs-comment">// rookie</span><br><span class="hljs-built_in">console</span>.log(person.friends)     <span class="hljs-comment">// [ &#x27;the shy&#x27;, &#x27;faker&#x27;, &#x27;zoom&#x27; ]</span><br><span class="hljs-built_in">console</span>.log(anotherPerson.friends)  <span class="hljs-comment">// [ &#x27;the shy&#x27;, &#x27;faker&#x27;, &#x27;zoom&#x27; ]</span><br></code></pre></td></tr></table></figure><p>可以看到，原型式继承还有引用类型的问题</p><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>寄生式继承，就是创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnother</span>(<span class="hljs-params">original</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> clone = <span class="hljs-built_in">Object</span>.create(original)<br>    clone.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> clone<br>&#125;<br></code></pre></td></tr></table></figure><p>在例子中，该函数为源对象增加了一个 sayHi 的方法，和原型式继承类似。</p><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>从前面看，组合式继承似乎就是最好最常用的继承方式，不过，它也有自己的不足，组合式继承无论在什么情况下，都会调用两次超类型的构造函数，第一次是在 new SuperType() 的时候，第二次是在调用 SuperType.call 的时候。</p><p>寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 相当于 subType 的原型对象不直接 new 出来，而是从 Object 继承下来</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> prototype = <span class="hljs-built_in">Object</span>.create(superType.prototype)<br>    prototype.constructor = subType<span class="hljs-comment">// constructor 指回构造函数</span><br>    subType.prototype = prototype<span class="hljs-comment">// prototype 指向原型对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.friends = [<span class="hljs-string">&#x27;the shy&#x27;</span>, <span class="hljs-string">&#x27;faker&#x27;</span>]<br>&#125;<br><br>SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    SuperType.call(<span class="hljs-built_in">this</span>, name)<br>    <span class="hljs-built_in">this</span>.age = age<br>&#125;<br><br>inheritPrototype(SubType, SuperType)<br><br>SubType.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age)<br>&#125;<br><br><span class="hljs-keyword">const</span> instance1 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&#x27;jerome&#x27;</span>, <span class="hljs-number">18</span>)<br>instance1.friends.push(<span class="hljs-string">&#x27;zoom&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(instance1.friends)  <span class="hljs-comment">// [ &#x27;the shy&#x27;, &#x27;faker&#x27;, &#x27;chen&#x27; ]</span><br>instance1.sayName() <span class="hljs-comment">// jerome</span><br>instance1.sayAge()  <span class="hljs-comment">// 18</span><br><br><br><span class="hljs-keyword">const</span> instance2 = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&#x27;rookie&#x27;</span>, <span class="hljs-number">19</span>)<br><span class="hljs-built_in">console</span>.log(instance2.friends)  <span class="hljs-comment">// [ &#x27;the shy&#x27;, &#x27;faker&#x27; ]</span><br>instance2.sayName() <span class="hljs-comment">// rookie</span><br>instance2.sayAge()  <span class="hljs-comment">//19</span><br></code></pre></td></tr></table></figure><p>这个例子的高效率提现在它只调用了一次超类型的构造函数，避免在 SubType.prototype 上创建不必要的、多余的属性。与此同时，原型链还能保持不变，寄生组合继承是引用类型最理想的继承范式。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
